## Lecture 2. Почему вы не можете не использовать API.
В прошлой лекции рассматривались "столпами" ООП: инкапсуляция, наследование, полиморфизм. Ест ещё столп, о котором 
спрашивают на собеседованиях. Это _**абстракция**_. В достаточно большом количестве вакансий этот пункт выделяется как 
отдельная часть, но в то же время иметь представление все таки нужно.

## 1. Абстракция.

Есть 3 основные столпа в которых нужно точно хорошо разобраться. Зная их, можно построить этот принцип _**абстракции**_.
В разных ЯП могут попросить определить какие-то дополнительные требования/столпы, относящиеся к ООП. Это тонкие моменты 
и это могут быть детали какого-то ЯП, и на них вот упор можно не делать. 

_**Абстракция**_ - это свойство системы, позволяющее описать общие характеристики базового класса для всех его 
производных классов, а наполнение деталями предоставляется каждому из этих классов.

Абстракция в самом простом представлении. Допустим создаем иерархию зданий. Есть базовое здание. От него наследуются 
условные: гараж, дом, магазин. Если придет заказчик, а мы строители и попросит создать здание. Понятно ли будет что 
нужно будет делать? Допустим, ага, если строится какой-то большой жилищный комплекс, очевидно что пришел заказчик 
построить ещё какой-то домик. А быть может мы стоим какую-то промзону и надо построить ещё один завод. В этом случае 
строитель будет уточнять. Для заказчика абсолютно очевидно, что здание нужно воспринимать в контексте той предметной 
области, которую заказчик обсуждает сос строителем. Но строитель может быть подрядчиком строек жилых зданий, промзон и 
для строителя это уже не очевидно. Да может быть из контекста получится понять, но в любом случае строитель будет 
уточнять.

Точно также и при проектировании своего кода надо вкладывать такие тонкие моменты и говорить: вот у нас есть здание, а 
вот просто так здание не дам тебе создать, ты, пожалуйста, уточни какое здание тебе нужно. 

В псевдоигре с предыдущего занятия получается след идея. Код `Ex000`. Но прежде чем продолжать работу с кодом, 
напомнить: для чего нужна `static`-ка? 

Допустим надо создать некий класс `Foo` любимый всеми программистами. В классе будет описана какая-то переменная 
`value`. Далее сделаем перегрузку `toString()` чтобы чуть-чуть быстрее показать что из себя представляет этот `value`.

    package lecture02.Ex000;
    public class Foo {
        public Integer value;
    
        @Override
        public String toString() {
            return value.toString();
        }
    }

Конструктор не будем реализовывать. 0:06:38. Создадим экземпляр класса `Foo`:

    Foo f1 = new Foo();
    f1.value = 123;

Можно создать ещё несколько экземпляров класса `Foo`: `f2`, `f3`. 

> Видно, что любой код работает со второго раза. Но всё-таки иногда бывают исключения и он будет работать с 3-го раза.

    System.out.println(f1.value);
    System.out.println(f2.value);
    System.out.println(f3.value);
    // 123
    // 222
    // 444

Видно, что поле `value` для каждого экземпляра оно своё. Соответственно, если сделать в рамках этого класса некое 
публичное статическое пока поле `count`. И создать некоторый конструктор, который будет увеличивать значение `count`.

    public static Integer count;
    
    public Foo() {
        //count++;
    }

Теперь идея. Есть тип `Foo`, есть экземпляр `f1`, то `value` для каждого экземпляра свой. Достучаться до `value` можно 
через экземпляр, который указали `f1`.

Если есть какая-то статика. К статике можно обращаться через имя типа. Соответственно, если указать `Foo.`, то 
появляется доступный этот самый `count`. Если где-то указать какое-то значение этого `count` через имя типа:

    Foo.count = 123000;

И определим некоторый публичный метод, который будет демонстрировать этот самый `count`:

    public void printCount() {
        System.out.println(count);
    }

> Особо прошаренные знают что завязывать взаимодействие на интерфейсе - "такое себе", но для демонстрации нормально.

`0:09:18`

Есть 3 экземпляра `Foo`: `f1`, `f2`, `f3`. Теперь вызовем метод `printCount()` на 1-м экземпляре.

    f1.printCount();
    Foo.count = 123000;
    ...
    f2.printCount();
    ...
    f3.printCount();

Затем по ходу идет присваивание значения через тип. Далее вызываем `printCount()` на 2-м экземпляре и потом на 3-м. 
Учитывая, что статика для всех экземпляров едина. То, на 1-м экземпляре получим значение по умолчанию `null`, т.к. 
используем класс-обертку. Дальше присваивание значения `123000` и для 2-го и 3-го экземпляра значение будет одинаково:

    null
    123000
    123000

`f2.printCount()` - на экземпляре 2-го, вызывая экземплярный метод, который обращается в свою очередь к статическому 
полю - можно увидеть значение `123000`, то же самое значение и у `f3`.

Если инициализировать `count`:

    public static Integer count = 0;

Инициализация статических полей, также можно ещё методы описывать - поле определяется до первого обращения к этому 
статическому полю. После запуска клиентского кода, вывод:

    0
    123000
    123000

Т.е. фактически до вызова `f1.printCount()` произошла инициализация, то значение поля не `null`, а `0`. 

Для более правильной, так сказать более красивой, инициализации статических полей есть `статический инициализатор`:

    static {
        count = 0;
    }

Где это может быть применено? Как ранее было видно в псевдо-игре, для подсчета нужных героев как раз определяли эту 
статику. 

    public Foo() {
        count++;
    }

Как выше, в конструкторе `Foo` будет увеличиваться `count`. Т.е. когда будет создаваться экземпляр `Foo` `Foo f1 = new
Foo()`, присваивается полю `value = 123`. В то же время был до 1-го обращения к статическому полю была инициализация. 
Соответственно, в момент создания вызывается конструктор, который "щелкает" это статическое значение. При создании 2-го 
экземпляра `count` увеличивается на 1-цу и т.д. Вывод:

    1
    2
    3

> Основной момент. `0:12:45`. Она работает не на экземплярах какого-то типа. Для того чтобы обратиться к статическим 
> членам класса нужно обращаться через имя типа (`Foo`). 

Теперь можно раскрыть основную идею самой 1-й лекции: почему надо писать какой-то `class Program`, внутри которого 
`public static void main(){}`? 

Есть класс, есть статический метод `main()`. Если описать какой-то статический метод `A()` в клиентском коде:

    static void A() {
        System.out.println("A()");
    }

И сейчас из статического метода `main()`, который является точкой входа, можно вызвать этот метод `A()` и все будет 
работать:

    A();
    // A()

Но как только убрать слово `static`, но все это перестает работать, даже не дает компилироваться. Ошибка:

    // java: non-static method A() cannot be referenced from a static context

Чтобы это заработало, надо создать экземпляр класса `Program`  и на нем вызывать экземплярный метод:

    static void A() {
        System.out.println("A()");
    }

    public static void main(String[] args) {
        Program prog = new Program();
        prog.A();
    }

И теперь в этом случае `static` можно не писать.

`Ex001`. Аналогичным образом, если внутри класса `Foo` есть статическое поле `count`, можно спокойно описать статические
методы. Если нужно чтобы пользователь не мог изменять значение `count`, но получать его значение в любой момент изменяем
модификатор `public` на `private` для поля `count`:

    package lecture02.Ex001;
    public class Foo {
        private static Integer count;

        public static Integer getCount() {
            return count;
        }
    }


Обращаясь к статическим членам (полям) в методах класса - `this/super` не нужно. Это связано с тем, что для статики 
нет никакой иерархии. То, что доступно здесь, будет работать через имя типа (`Foo`). Т.е. нет текущего экземпляра, 
чтобы обратиться к `this` и нет никакого базового, который бы относился к хранению этого значения.

В то же время возможно сделать доступность видимости как в текущем классе, так и у наследников текущего типа. Для чего 
это делается? Простой пример был на 1-й лекции. Брали базовый тип, в рамках этого типа храниться внутреннее барахлишко, 
через экземпляр можно "щелкать" и таким образом подсчитывать, в нашем случае, героев. То же самое примерно и здесь.

> Основной момент. У нас есть статика, которая позволяет обращаться к членам через имя типа. В соответствии с 
> модификаторами доступа, которые известны: `public` - доступен откуда хочешь, `private` - в текущем классе, 
> `protected` - в текущем классе и производных этого класса.

Самый простой пример `Ex002`. Есть класс `Doo`, который расширяет класс `Foo`. Внутри `Doo` описываем экземплярный 
член - метод `M()`, который через `Foo` имеет доступ к `getCount()`, потому что `getCount()` `public`, но не имеет 
доступа к `count` с модификатором `private`. Если поменять у `count` модификатор на `protected`, то появится доступ к 
`count` и с ним можно работать (изменять). Поэтому нужно помнить о такой возможности. 

Но! Только те, которые начинают разбираться с ООП, в некоторых случаях возникает желание при невозможности 
спроектировать код так, чтобы мог работать на экземплярах, они начинают везде и всюду пихать эту самую статику.

> Статику нужно использовать крайне аккуратно, а на старте обучения лучше забыть о ней совсем. Если прямо очень хочется 
> что-то написать через статику, будь то методы статические, или члены статические, скорее всего проектирование неверно.

Почему препод делал в таком варианте? Дело в том, что ещё мало написано кода, потому что нужно было хранилище для 
подсчета персонажей. Но в нормальных реалиях можно создать немного по другому. Выделить отдельную компоненту, которая 
хранила бы наших героев, в рамках её через экземпляры щёлкали количество созданных этих самых экземпляров. `0:19:35`

> Далее в курсе архитектур возможно будут об этом рассказывать (хочется верить), а если не будут надо обязательно об 
> этом спросить: как данную задачу решить без использования статики. Поверьте, вариантов масса.

Сейчас известно, что есть статические члены, в нашем случае пусть будет простая ситуация: есть статические поля, есть 
статические методы, также есть статические инициализаторы. +/- запомнили и отложили в долгий ящик, когда потребуется 
быть может будем использовать. Очень удобно бывает статика для локальных конфигов - это как один из сценариев 
использования. Можно ли сказать: что так делать всегда? Точно нет, хранить конфиги в статических классах - такое себе.
Но рамках текущего какого-то проекта можно спокойно, а дальше уже сделать так как нужно.  

Следующая задача потихоньку переходить в Объектно Ориентированный Подход и продолжать разбираться с абстракцией. 
Возвращаемся к псевдо-игре и посмотрим где можно или нужно внедрять абстракцию. `Ex003`.

Идея. Есть основной класс `BaseHero`. Создаем список героев `teams` с продуманной иерархией: `Priest`, `Magician`, 
`Druid`. Также имеется возможность создания `BaseHero`. Насколько это правильное поведение? Что такое: создать героя, 
героя типа "Герой"? Это примерно как приехали на заправку и сказали: заправь мне топлива. Какое топливо? Будь то 
дизельное, или АИ-92, 95 и т.д.? Или пришли в магазин и сказали: дайте молоко марки "Молоко". Скорее всего нас не 
поймут. Здесь тоже надо создать героя типа "Герой". С точки зрения логики здесь ломается, если не являешься 
проектировщиком этого приложения. Поэтому от "герой типа Герой" нужно избавляться.
`0:22:28`.

Если в примере `Ex004` добавить одно волшебное слово `abstract` в класс `BaseHero`:

    public abstract class BaseHero { }

Теперь класс `BaseHero` является абстрактным. Остальное можно ничего не менять, но если обратить внимание на пункт в 
клиентском коде создания персонажа типа `BaseHero` невозможно, т.е. запрещено. 

Т.е. если хочешь ограничить создание каких-то экземпляров какого-то типа, в это м случае говоришь что класс будет 
_**абстрактный**_. В нем может быть какой-то функционал с точностью до модификаторов доступа: `public`, `protected`, 
`private`, но в то же время нет возможности создать экземпляр этого типа. 

Аналогичным образом, когда работаешь с потоками, условно, есть такое понятие в программировании - _**потоки**_. 
Бывают потоки: двоичный, поток на запись, поток для работы с памятью. Тогда, если потребуется создать какой-то поток, 
можно сказать: "нужен двоичный поток для работы с чем-то там...". Или, "нужен поток для работы с памятью", но нельзя 
сказать: "создать поток типа поток". Непонято что, нет однозначности. Поэтому сама идея создания потока является 
абстрактным классом, который есть, в нем есть какой-то функционал, базовый, но конкретные детали того как нужно работать 
с потоком уже будет отдаваться на откуп конкретному наследнику. Примерно то же самое можно реализовать и нашем коде.

В `BaseHero` можно ещё описать некоторый метод `die()` когда в ситуации количество жизни становится малым, хочется чтобы
у каждого героя был это метод. Но каждый герой может умирать по своему.

В частности, если это игра, то у каждого персонажа в момент смерти будет проигрываться своя анимация и быть может 
воспроизводиться какой-то определенный звук, или какая-то речёвка. В этом случае мы точно знаем что будет вызван метод 
смерти, а вот как этот метод будет реализован - будут решать конкретные наследники. Но, заложить этот метод в контексте 
базового класса можно спокойно, более, если этот класс абстрактный. 

Итак, пусть будет некоторый метод `public void die()` и дальше по всем канонам нужно сделать какую-то реализацию этого 
метода. Но если нет возможности создать экземпляр этого типа `BaseHero`, то и метод экземплярный нельзя вызвать. Есть 
хитрость: метод будет, но абстрактным `public abstract void die()`. А если метод абстрактный и его никак нельзя вызвать 
потому что экземпляр класса абстрактный, то в этом случае и тело метода описывать не нужно. Но в методе `protected void 
getDamage()` его можно спокойно вызвать. 

Почему? Потому что:
1. иерархия типов;
2. есть базовый герой, от которого наследуется кто-то там...;
3. этот кто-то там будет реализовывать всё что есть в базовом классе;
4. если потребуется что-то явно определить, как в данном случае абстрактный метод, то конкретный представитель опишет 
(разработчик) ту логику, которая должна быть вызвана.

Но, вызываться метод будет в контексте базового класса. Т.е. Мы знаем что есть метод, точно знаем что он будет работать.
Теперь любой наследник требует реализации этого метода. `0:26:22`
IDE, например, для класса `Druid` укажет ошибку и предложит добавить/имплементировать (`implement`) метод `die()`:

    @Override
    public void die() {  }

И здесь описывается та логика, как должен умирать данный тип персонажа `druid`. Если мы знаем что лечение персонажа 
всегда одинаково - увеличить жизнь, а как будет умирать персонаж - можем описать по-разному. В то же время можно 
абсолютно сделать чтобы `BaseHero` был полостью абстрактным со всеми абстрактными членами. Например, продумываем такую 
игру, в контексте которой ,напр., лечение должно сопровождаться какой-то специфичной анимацией. Если друиды - танец 
плясать, если жрецы - должны подпрыгивать, если это паладины - вокруг себя вертеться. Почему бы и нет? В таком 
случае говорится. Есть абстрактный `BaseHero`, есть абстрактные методы: `healing()`, `die()`, `getDamage()` и т.д. Т.е. 
всё только абстрактное. Дальше делать наследование/включение какого-то класса. Определяем логику, как конкретный 
представитель этой иерархии будет реализовывать данные методы. И описывать ту логику, которую придумаешь. 

> Обязательно надо попробовать на простых примерах, потому что казалось бы всё просто, но как показывает практика всё не
> сильно просто, особенно когда сам начинаешь писать код.

След пример, есть возможность описывать иерархию больше чем 1 класс, т.е. есть `BaseHero` и у него есть наследник 
`Priest`. В некоторых случаях приходится продумывать какую-то более сложную иерархию: есть базовый класс `Hero`, есть 
какие-то 2 фракции, воюющие между собой, напр., `Alliance`, `Orda`; дальше у альянса есть свои представители, у орды 
есть свои представители. Но для них справедлива одна и та же механика игры. 

Каким образом создаются такие экземпляры? Самый важный момент: как обеспечить взаимодействие этих экземпляров между 
собой? Напр., не будем говорить сейчас, что условный герой из фракции "альянс" не может полечить героя из "орды". Это 
все спокойно описывается на соответствие типа. Рассмотрим простые примеры. `Ex005`

Есть иерархия. Базовый абстрактный класс `BaseHero`, есть классы-наследники `BaseHero`: `Druid`, `Magician`, `Priest`.
Теперь ещё добавляется в иерархию `Alliance`: `Dwarf` наследник `Druid`, `Gnome` наследник `Priest`, `Human` наследник 
`Druid`, `Worgen` наследник `Priest`, `Gnome` наследник `Priest`. Т.е. иерархия сильно усложняется.

Дальше вопрос: будет ли дальше работать так как работало до текущего момента? В общем случае, да, если нигде явно не 
указывали что это абстракт. И вот, напр., экземпляр типа `Human` нельзя создавать потому что он абстрактный, тогда 
безусловно невозможно. В остальном всё +/- то же самое. Описана логика базового класса, она точно также переносится на 
всех своих потомков. Поэтому, если хочется с точки зрения создания экземпляров, всё работает, как и работало до текущего 
момента. Если требуется создать условного `Human` - берем и делаем. Но нужно обратить внимание с точки зрения 
взаимодействия типов между собой. И вот с точки зрения `BaseHero` посмотрим. Нужно разобраться это в каком порядке 
вызываются конструкторы классов. 

Идея. Есть некий жрец `priest`, посмотрели о нем информацию, также с друидом и магом:

    Priest priest = new Priest(); 
    System.out.println(priest.getInfo());
    Druid druid = new Druid(); 
    System.out.println(druid.getInfo());
    Magician magician = new Magician(); 
    System.out.println(magician.getInfo());

Для друида может выступать класс `Druid`, а также `BaseHero`. В то же время обратить внимание, как только в качестве 
базового типа используете то, что не реализует какую-то конкретную логику, напр., `.healing()` - всё потихоньку начинает 
ломаться. Это не значит, что написали неверный код. Это лишь значит, что начинаем переписывать взаимодействие сущностей 
между собой, а значит быть может и поведение также должно меняться. В общем случае если нам требуется, мы спокойно 
можем нашего экземпляра друида `druid` "скастовать" к типу `Druid`, главное не запутаться в скобках.

    BaseHero druid = new Druid(); 
    System.out.println(druid.getInfo());
    ((Druid)(druid)).healing(magician); 
    System.out.println(magician.getInfo());

Дальше с точностью до иерархии, если есть какой-нибудь `Dwarf` наследник `Druid`, то для экземпляра `dwarf` можно 
использовать в качестве базового типа `Druid` и точно также можно использовать `BaseHero`. `0:31:58` 

        //#region
        BaseHero dh = new Druid();
        /*BaseHero*/
        Dwarf dwarf = new Dwarf();
        // dwarf.dwarf_method();
        // ((Dwarf)dwarf).dwarf_method();
        System.out.println(dwarf.name);
        //#endregion

> Обязательно надо посмотреть каким образом это может быть сделано. Потренироваться. Как происходит обращение к типу, 
> который находится выше по иерархии?

Когда описываются достаточно сложные иерархии, пример есть на картинке `class.png` в `Ex006`, а также в архиве с доп 
материалами, в каталоге `Ex004`, есть базовый тип `BaseHero`, есть его производный тип `Druid`, от которого также будет 
производиться `Dwarf`.

Ситуация, когда будем уходить от `BaseHero` в `Druid`, наз., _**downcast**_. Т.е. иерархия идет сверху вниз. Когда надо 
подняться в иерархии выше, в этом случае наз. _**upcast**_. 

`Druid` можно спокойно "апкастить" до `BaserHero`, но нужно быть внимательным. Если я создаю тип `Druid`, то не могу его 
привести к экземпляру типа `Dwarf`. Те. я не могу сделать "даункаст" без предварительного "апкаста". В самом простом 
примере можно попробовать создать `druid` и его апкастить до `dwarf`. 

#### Прядок вызова конструкторов в ООП.
Следующий момент в ООП. Это в каком порядке вызываются конструкторы в достаточно больших иерархиях. `0:33:30`

Пример `Ex006`. В коде используется иерархия согласно картинке `class.png`. Есть базовый класс `BaseHero`, в котором 
удалено всё из прошлых примеров, остались 2 конструктора: с двумя аргументами и без аргументов. Аналогично реализованы 
классы-наследники `BaseHero`: `Druid`, `Dwarf`.  

> Обратить внимание как реализованы конструкторы.

Есть базовый вызов с 2-мя аргументами конструктора `BaseHero`. Далее в конструкторе по умолчанию происходит вызов 
текущего конструктора с 2-мя аргументами `this()`. В методах делается пометка того что было вызвано. 

Есть класс `Druid`. У `Druid` есть конструктор с 2-мя аргументами, который вызывает конструктор базового класса и делает
пометку, что он был вызван. 

Для чего может потребоваться такая иерархия в принципе? Есть базовый класс `BaseHero`. У базового класса есть поле `hp`,
далее инициализируем, т.е. полю `this.hp` присвоить значение `hp`, которое пришло из конструктора.

    public abstract class BaseHero {
        int hp;
        public BaseHero(String name, int hp) {
            this.hp = hp;
        }  }

На след этапе создаем некого друида, у которого есть "manapoint". И надо описать конструктор друида так, чтобы в 
конструктор можно было бы передавать ману конкретно для этого персонажа.

    public class Druid extends BaseHero{
        int mp;
        public Druid(String name, int hp, int mp) {
            super(name, hp);
            System.out.println("Вызван Druid(String name, int hp)");
            this.mp = mp;
        } }

> Важный момент. При чем сначала инициализируем то что в базовом классе, дальше переходим к конкретному экземпляру и 
> инициализируем у него конкретные поля (свойства).

Нужно обратить внимание. Может быть случилось что-то нехорошее в игре и как только персонаж будет создан - он попадает 
под действие какой-то ауры, действие которой можно сразу проверить в конструкторе. Является ли такое правильным? 
`0:35:50` Это отдельный вопрос. Но допустим, мы можем проверить саму идею того что на нас влияет ли какая-то аура и 
аура, которая уменьшает количество здоровья на 10%, независимо что с нами происходит.

    public Druid(String name, int hp, int mp) {
        super(name, hp);
        System.out.println("Вызван Druid(String name, int hp)");
        this.mp = mp;
        this.hp = (int) (this.hp * 0.8); // реинициализация здоровья
    }

В результате чтобы то ни было, у нового персонажа друида здоровье изначально будет меньше на 20%. Это всего на всего 
идея использования. т.е. после того как пробросили в базовый класс, там всё проинициализировали, потом вернулись к 
текущему классу и доделали то что требуется. Но эту логика далее не нужна. 

Дальше есть `Dwarf`. Здесь тоже какая-то логика. Важный момент здесь заключается в том что когда вы пишете `Dwarf 
extends Druid` в данном случае этим `super()` базовым классом для `Dwarf` будут являться друиды. 

Дальше иерархия конструкторов. В клиентском коде.

    System.out.println("\nDwarf dw1 = new Dwarf()");
    Dwarf dw1 = new Dwarf();
    System.out.println(dw1);

    System.out.println("\nDwarf dw2 = new Dwarf()");
    Dwarf dw2 = new Dwarf();
    System.out.println(dw2);

    System.out.println("\nDwarf dw3 = new Dwarf()");
    Dwarf dw3 = new Dwarf();
    System.out.println(dw3);

    // Вывод
    Dwarf dw1 = new Dwarf()
    Вызван BaseHero(String name, int hp)
    Вызван Druid(String name, int hp)
    Вызван Druid()
    Вызван Dwarf(String name, int hp)
    Вызван Dwarf()
    lecture02.Ex006.Dwarf@36baf30c

Объяснение. `0:37:31`. Посмотрим каким образом происходит каскад вызовов этих конструкторов. Итак, создаем экземпляр 
`dwarf` (dw1). Это можно просматривать через клавишу `F12`. Жмём F12 на `Dwarf()` в `new Dwarf()` клиентского кода, 
перебрасывает на конструктор по умолчанию `Dwarf()` ,который в свою очередь вызывает через `this()` конструктор текущего
класса. Жмём F12 на `this()` и попадаем на конструктор `Dwarf()` с 2-мя аргументами, в нем через `super()` по F12 
попадаем в конструктор по умолчанию `Druid()`, который вызывает конструктор с 2-мя аргументами текущего класса 
`Druid()`. Этот конструктор через `super()` вызывает конструктор с 2-мя аргументами базового класса `BaseHero`.
Далее в этом конструкторе происходит инициализация `hp` через `this.hp` и далее вся эта иерархия начинает возвращаться 
в том же порядке обратно, подобно рекурсии. Дальше, если есть инициализации каких-то полей в каждом конструкторе они так
по цепочке будут инициализироваться. В конце по `System.out.println(dw1)` видим информацию по созданному 
персонажу/объекту. 

Примерно так происходит иерархия вызовов конструкторов. `0:40:29`

До текущего момента строили иерархию, когда есть что-то базовое и от него есть наследники - там всё примерно +/- 
одинаково. При чем конструкторов может быть не 2, а 10, 20. Конечно, это такое себе проектирование, если просто 20 
конструкторов описываешь в контексте текущего экземпляра. Быть может для этих целей использовать что-то более удачное. 
Предположим, что есть такая ситуация. Можно из конструктора в конструктор, в конструктор между собой как-то прыгать и в 
конечном итоге дойдет до базового конструктора. А может быть всё это не нужно будет. Всё зависит от тех задач, которые 
будешь решать. Но главное саму идею того: какая иерархия вызова конструктора происходит. 

> Промежуточный итог по абстракции. Идея: в абстрактном классе определяются лишь общие поля и характеристики методов, 
которые должны быть в производных классах.

`0:41:30`
Если класс абстрактный то экземпляры этого класса создать нельзя, следствие вызвать экземплярные методы нельзя, а значит
спокойно можно не описывать логику, что должно происходить в этих методах. Определяем что есть какое-то поведение, а с 
реализацией пусть разбираются те кто "помоложе", в контексте иерархии кто будет производным этого класса. Поэтому такие 
дела. `0:41:52`.

Дальше если говорить об абстрактных классах, то здесь +/- всё понятно. След идея: разобраться что такое _**интерфейс**_?

### Интерфейс. `0:42:02`

_**Интерфейс**_ предназначен для описания исключительно общего поведения сущностей.

**Частный случай**: для гарантии, реализации некоторого поведения. Т.е. фактически есть какой-то интерфейс и ты уверен, 
что такой функционал должен быть у класса, который этот интерфейс будет включать. Или может в разных ЯП это по-разному 
называют. Можно даже в какой-то степени сказать "наследуется от интерфейса", в кругу программистов точно поймут.



> Интерфейс - это частный случай класса. Он представляет собой полностью абстрактный класс с абстрактными членами.

Фактически, если грубо говорить, у нас будет класс в котором все члены абстрактные - создается интерфейс. Да, 
безусловно, если копать в детали, то можно чтобы и статические члены были в рамках интерфейса и т.д. Но это не есть 
сейчас главное. Т.е. условно в Java такая возможность есть, а в условном C# такого нет. Делать упор на какие-то детали 
сейчас не важно. 

Каким образом, с точки зрения ООП, описывается идея интерфейса. 

> Важный момент. В контексте Java нет множественного наследования от класса, т.е. нельзя сказать что есть `BaseHero1` и 
> `BaseHero2` в качестве базового потому что непонятно к кому обращаться через `super()`. К кому конкретно обращение?

Но в то же время есть возможность реализации некоторого количества интерфейсов. Соответственно, идея лечения будет 
выделена, или вынесена в отдельный интерфейс и идея нанесения урона будет вынесена в отдельный интерфейс. Дальше, играя 
с этими интерфейсами, персонаж может быть лекарем, или воином. В разных играх это по-разному реализовано, напр., 
перекачиванием веток таланта, или переключение способностей и т.д. В зависимости от того какой интерфейс мы 
используем будет доступен тот, или иной функционал. 

`0:44:00` Пример кода `Ex007.v1`. Первая идея использования. Не вдаваться в детали, всё-таки уход в сторону 
проектирования когда не важно как внутри описан тот, или иной метод. Главное, это идея как можно это реализовать. 
Имеется абстрактный класс `Hero`. Выделяем класс `Healer` в группе `Healers`, который будет наследником `Hero`. В 
рамках этого класса будет метод лечения `healing()`. Абсолютно также будет класс `Warrior` в группе `Warriors`, который 
будет наследником `Hero` и у него будет метод атаки `healing()`. В группе `Warriors` будет класс `Warrior` и ещё два 
класса `Knight` и `Paladin`, которые являются наследниками `Warrior`. Аналогично с группой лекарей `Healers` в которой 
есть класс `Healer` и от него наследуются: `Priest`, `Shaman`, `Druid`. 

Далее в рамках клиентского кода можно описать иерархию где в качестве базового типа выступает `Hero` (List<Hero>) и 
дальше наполнять нужными типами:

    // #region team1
    List<Hero> team1 = new ArrayList<>();
    team1.add(new Druid());
    team1.add(new Shaman());
    team1.add(new Paladin());
    team1.add(new Druid());

Но в то же время можно фактически попробовать привести нужную переменную, напр., `h` к `Warrior`. Если `h` является 
таким типом `Warrior` `h instanceof Warrior`, то приводим к типу воина и вызываем на нём атаку 
`((Warrior) h).attack(null)`.

> Напрямую `h.attack(null)` метод атаки работать не будет, потому что команда `team` наполняется типом `Hero`.

Аналогичная ситуация с лекарями `h instanceof Healer`.

    if ( h instanceof Warrior) {
        ((Warrior) h).attack(null);
    } else if (h instanceof Healer) {
        ((Healer) h).healing(null);
    } else {
    // ...
    }
    // #endregion

Смысл кода выше, что если персонаж воин, то он атакует, а если лекарь то лечит, а иначе `else {// ...}` можно сказать 
что это какой-то сторонний наблюдатель. Таким образом можно описать зрителя, или нейтрального персонажа. 

На след этапе `#region team 2` допустим можно указать тип `Warrior`. В этом случае можно наполнять исключительно только 
теми, кто является воинами. Напр., друидами не получится `0:46:38`, т.к. друид находится на одном уровне это самой 
иерархии. Если создаешь команду героев воинов, то не нужно ничего ни к чему проверять и приводить, т.к. знаем что у всех
воинов есть метод атаки:

    team2.get(0).attack(null);

Поэтому можно пропускать проверку `instanceof` и "кастовать" к нужному типу. Без проверки это будет немного быстрее 
работать. Но и с другой стороны, без проверки код становится проще.

Дальше создаем команду лекарей:

    List<Healer> team3 = new ArrayList<>();
    //team2.add(new Paladin());
    team3.add(new Druid());
    team3.add(new Shaman());

И знаем что туда никакой воин точно не сможет попасть, напр., `Paladin`. Это с точки зрения использования классов и 
построения иерархий именно с точки зрения классов. 

Но, если `Hero` является абстрактным классом. Дальше в общем случае, если у нас пусть базовые типы `Healer` и `Warrior` 
будут являться абстрактными. Т.е. мы не можем создать героя типа `Hero`, но в то же время есть проблема: что если в 
некоторых играх паладины могут лечить и атаковать? Каким образом сделать такую реализацию? В контексте использования 
классов это фактически не получится, либо надо будет обязательно вшивать какое-то поведение паладину: он точно должен 
быть наследником воина, но в то же время у него есть свой функционал лечения. Как обходиться с взаимодействием с другими
классами? Что будет не 6 классов, а 26 классов, каждый метод прописывать, делать перегрузки? В общем это всё очень 
сложно. Вот в этом случае хорошо выручают интерфейсы.

### Интерфейсы. `0:48:50`

`Ex007.v2`
А решение с помощью интерфейсов не сильно отличается. Т.е. по прежнему есть абстрактный класс `Hero`. Теперь у нас есть 
интерфейс `Healer` в классе `Healer` у которого есть метод `healing()` принимает аргумент `Hero target`. И всё, здесь 
даже не нужно описывать то, что будет делать этот метод. Аналогично с классом `Warrior` у которого интерфейс `Warrior` и
метод атаки `attack`.

    public interface Healer {
        void healing(Hero target);
    }

    public interface Warrior {
        public void attack(Hero target);
    }

Допустим жрец `Priest` будет наследником `Hero`, но будет имплементировать (реализовывать) интерфейс `Healer`. Описываем
логику метода лечения (перегрузку метода). Аналогично с шаманом.

Точно также с воинами. Рыцарь `Knight` будет наследником `Hero`, но будет реализовывать интерфейс `Warrior`. В этом 
классе описываем метод атаки (перегрузку).

    public class Knight extends Hero implements Warrior {
        @Override
        public void attack(Hero target) { 
        }   }

Можно создать некоторый класс `God`, который будет наследником `Hero`, но в то же время будет реализовывать несколько 
интерфейсов `Healer` и `Warrior`. В этом классе можно описать методы: лечения и атаки.

Со стороны клиентского кода всё остается точно также:
1. можно создавать коллекции и добавлять экземпляры классов;
2. кастовать (`instanceof`) вверх, или вниз, куда надо;
3. создавать отдельно коллекцию воинов `List<Warrior>`;
4. точно также создавать коллекцию лекарей и наполнять её экземплярами.

Экземпляр класса `God` можно свободно добавить в коллекцию лекарей, т.к. он реализовывает интерфейс `Healer`:

    team2.add(new God()); // команда атакующих
    team3.add(new God()); // команда лекарей

Если этот экземпляр типа `God` будем вызывать из контекста `team2` то будет доступен метод атаки, а если из `team3` то 
метод лечения. Добавив в коллекцию лекарей, можно его скастовать к интерфейсу `Warrior` и сделать атаку.

    ((Warrior) team3.get(2)).attack(team1.get(1));

`God` приводится к типу `Warrior` и применяет атаку к экземпляру команды `team1`.

Для практики нужно пробовать как всё это работает? Каким образом это можно в контексте иерархии наших классов 
реализовать? Можно воспользоваться примером с использованием интерфейсов, ну или в общем случае с использованием 
абстракции. `0:54:27`

Идея следующая. С одной стороны задачка звучит очень просто, с другой стороны нужно подумать как можно это реализовать?
Имеется текстовый редактор, позволяющий сохранять в разных форматах. Наверняка это делали при помощи Microsoft Word. 
Когда можно сохранить в старом формате `.doc`, или в новом `.docx`, или в `.txt`. Если работали с таблицами то: `.xls`, 
`.xlsx`, `.csv`. То же самое, если работаешь в граф редакторе, то там свои форматы. Вопрос: каким образом реализовать 
некоторый функционал, позволяющий в зависимости от того какая кнопка зажата, сохранять в том, или ином виде? Обратить 
внимание: не интересно то, какие типы файлов будут использованы. Но интересно как будет продумана иерархия тех классов, 
которые будут отвечать за отдельные типы. (подсказка) Т.е. когда начинаешь думать об архитектуре своего приложения, то
нужно мыслить не тем "... что мне нужно написать метод, который как-то там должен сохранять в формат `.xml`...". Нужно 
продумывать в контексте "... нужно написать что-то, что будет сохранять в каком-то формате, а какой формат должен 
указать пользователь. Если он нажмёт кнопку `Markdown`, значит нам нужно каким-то образом сохранить в Markdown. Если 
укажет в `.xml`, значит нужно сохранить в XML..." И в зависимости от этого отдадим задачу менее опытным программистам и 
скажешь: "Я тут продумал классную иерархию, а ты реализуй работу с XML, а ты в Markdown и т.д."

Разбор задачи `1:01:37`, пример `Ex008`. 

Начнем разбор с интерфейса `Saveable`, который будет хранить кнопку `SaveAs`:

    public interface Saveable {
        void SaveAs(TextDocument document, String path);
    }

Как там это будет сделано не знаем, но знаем что кнопка сохранения должна быть. В качестве "аргумента" этой кнопки нужно
передать формат файла `TexDocument document` и как следствие путь к этому файлу. В качестве формата используется 
иерархия `TextDocument` (класс), в котором есть какой-то функционал.

> Важный момент! Находимся на этапе, где не нужно всматриваться в каждую строчку. "О, здесь как-то инициализация 
> `StringBuilder`". Потом открыть Google, документацию по Java и почитать что такое `StringBuilder`? Если этого не 
> знаешь. Основная идея научиться мыслить в таком варианте: есть какой-то метод и он как-то работает. Как он работает 
> вообще не интересно. Основная задача - создать какую-то иерархию.

Причем обратить внимание, сейчас должен смотреть не с точки зрения: а вот там какая-то деталька реализована? Что такое 
`StrinBuilder`? Как он тут инициализируется? Сейчас надо видеть кнопку `SaveAs` и задача: понять `SaveAs` и в качестве 
аргумента передать формат. А дальше: есть `Markdown`, найти интерна, или Джуна, дать ему задачу и иди занимайся как там 
будет сохраняться в: `.md`, `.xml`, или в каком-то другом формате. Пусть Джун разбирается, а мы начинаем думать немного 
высшими материями. (на самом деле этим и занимаются Джуны) В большинстве случаев, низкоуровневую иерархию продумывают 
всё-таки Джуны. Более общую, так сказать, архитектуру продумывают кто повыше. Будем считать, что всё приложение - что-то
большое, а вот конкретный тип формата файла - низменное, пусть разбираются Джуны.

Есть формат `TextDocument`, в котором есть какая-то логика сохранения файлов. Дальше создается отдельный формат (класс) 
`Doc` и в нем какая-то логика. Есть формат `Md`, `Txt` и они как-то работают. Дальше есть класс `Notepad`, который 
содержит коллекцию, параметриризированная `TextDDocument` и какая-то логика:
1. `Notepad()` - инициализация;
2. `newFile()` - создание нового файла;
3. `currentDocument()` - может быть получение текущего документа;
4. и т.д.

Клиентский код:

    public class Program {
        public static void main(String[] args) {
            Notepad notes = new Notepad();
            notes.newFile();
            notes.currentDocument().addAllText("text1");
            notes.currentDocument().addAllText("text2");
            notes.currentDocument().addAllText("text3");
            notes.SaveAs("file1", new Txt());
            notes.SaveAs("file2", new Md());
            notes.SaveAs("file3", new Doc());
        }   }

С точки зрения логики, что сделано? Создана новая записная книжка `notes`. Далее создан новый файл. Дальше добавляется 
нужный текст. Далее сохранятся методом `SaveAs`, но в метод передается: куда сохранить и формат сохранения. Причем 
формат - это какое-то `.txt`, а в соответствии с логикой как должен сохраняться формат `txt`. Т.е. в кнопку передается 
та логика, которая должна использоваться в момент сохранения. Примерно также работает, напр., видео конвертер. Когда 
указываешь "Сохранить как...", напр., `.mp4`, в зависимости от того, какой формат выбираешь, в соответствии с этим 
выбирается кодек видео, звука, качество видео и звука, контейнер для сохранения данных (в данном случае `.mp4`). 

Пример с картинками. Когда используется `JPG`, то используется сжатие, т.е. идет потеря качества. В `PNG` идет без 
потери качества. В `GIF` там палитра максимум 256 цветов. `1:06:28` И здесь же та же самая ситуация. Есть наш документ, 
в рамках этого документа есть 3 разных формата файлов, каждый из этих форматов использует свою логику как переваривать 
информацию, а мы выбираем, напр., сохранение в `.txt`. 

При таком подходе в создании приложения, реализацию в `.txt`-формат выполняет один человек, реализацию в `.md` выполняет
2-й человек и т.д. И даже этим людям не нужно находится рядом и как-то это обговаривать. Почему? Потому что, есть общая 
логика, независимая от того что именно будем делать, у нас должен быть метод, который называется так, в качестве 
аргумента принимает вот такое и в качестве результата выдает такое. Дальше всё это детали.

Теперь надо мыслить ещё абстрактнее. 
