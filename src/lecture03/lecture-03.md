## Некоторые стандартные интерфейсы Java и примеры их использования.

План:
1. Введение
2. Iterator<E>
3. Iterable<E>
4. Comparator<E>
5. Comparable<E>
6. Comparable, equals, ==
7. foreach для своих типов
8. Примеры
9. Итоги

Пример. В теме абстракции узнали, что существуют абстрактны классы. Дальше классы могут быть полностью абстрактными со 
всеми абстрактными членами. Дальше, для того чтобы создать экземпляр такого класса нет возможности, но можно сделать 
иерархию, т.е. наследовать какой-то класс от полностью абстрактного и реализовать в нем всю логику, соответственно 
дальше использовать экземпляры, но можно сделать чуть проще.

Пример `Ex000`. Пусть будет абстрактный класс `Foo`, который имеет абстрактный метод `m1()`. Технически, таких методов 
может быть много.  

    public abstract class Foo {
        public abstract void m1();
        //public abstract void m2();
    }

Как создать экземпляр такого класса? В клиентском коде создать экземпляр след образом не получится:

    Foo foo = new Foo();

`IDE` предлагает имплементировать метод класса `Foo`, анонимный:

    public static void main(String[] args) {
        Foo foo = new Foo(){
            @Override
            public void m1() {
                System.out.println("m1");
            }
        };
        foo1.m1();
    }

Теперь прямо в клиентском коде можно описывать логику метода `m1()`, а потом вызывать его. Если требуется экземпляр с 
другим поведением `0:05:08` Если требуется экземпляр с другим поведением. С одной стороны кажется простым, с другой 
кажется громоздким, но иногда может быть полезным. Для чего это нужно? Позже будет видно.

Следующий пример. `Ex001`. Создаем коллекцию чисел `nums` и наполняем её. Для коллекции можно использовать итератор 
через метод `iterator()`, обращаясь к коллекции и приводим к нужному типу `Iterator<Integer>`. Дальше перебирается 
циклом `while`.

    public static void main(String[] args) {
        List<Integer> nums = new ArrayList<>();
        nums.add(1);
        nums.add(12);
        nums.add(123);
        nums.add(1234);
        nums.add(12345);

        Iterator<Integer> iter = nums.iterator();
        while (iter.hasNext()) {
            System.out.println(iter.next());
        }   }

Но если создать экземпляр `Worker` - классический класс с полями, конструктором и каким-то методом:

    Worker worker = new Worker("Имя", "Фамилия", 23, 4567);

То естественным способом не получится обратиться к методу `iterator()`, потому что он не реализован:

    Iterator<Object> components = worker.iterator();

Как заставить ходить по отдельным членам нашего класса? Как раз для этого и существуют интерфейсы, которые облегчают 
жизнь. Следующий пример. `Ex002`. Есть класс `Worker`, имплементируем/реализуем итератор через строки `<String>`.

    public class Worker implements Iterator<String> { }

Внутрення кухня класса не меняется, есть: поля, конструктор, какая-то внутрення логика `fullName()`. Идея с итератором 
заключается в том, что есть индекс `index`, который будем щелкать после того когда проверяем определенные условия:

    @Override
    public boolean hasNext() {
        return index++ < 4;
    }

`0:07:41`. В классе `Worker` 4 поля, поэтому когда индекс станет больше 3, то дальше ничего делать не нужно. Дальше 
как-то описывается метод `next()`:

    public String next() {
        switch (index) {
            case 1:
                // return firstName;
                return String.format("firstName: %s", firstName);
            case 2:
                // return lastName;
                return String.format("lastName: %s", lastName);
            case 3:
                // return age;
                return String.format("age: %s", age);
            case 4:
                // return salary;
                return String.format("salary: %s", salary);
        }
            return null;
    }

Этот метод делает проверку на значение индекса и в зависимости от текущего индекса выполнить то, или иное действие. 

Можно в объявлении класса `Worker`, в `Iterator<Object>` выбрать тип `Object` и делать простые возвраты через `return`, 
напр.:

            case 2:
                return lastName;

`0:08:15`. Какая будет реализация - зависит от предпочтений. С точки зрения логики, если всё сводится к строке, то всё 
нужно приводить к строке. Главное, есть `hasNext()`, `index`, который будет использоваться для пробежки по внутренним 
членам `switch/case` и, соответственно, логика `next()`.

Был итератор `iter()`. Теперь попробуем проделать то же самое с `worker`, клиентский код:

    Worker worker = new Worker(
        "Имя", "Фамилия", 23, 4567);

    Iterator<String> components = worker;

    while (components.hasNext()) {
        System.out.println(worker.next());
    }

Через `components` смогли напрямую привести к итератору, а потом используя функционал класса `Worker` пройти по членам.

Итак, описали логику, теперь можно спокойно тестировать, смотреть что будет. Только нужно обратить внимание: в 
предыдущем варианте был `.iterator()` потому что явно обращались к методу; теперь можно напрямую, используя экземпляр 
`worker`, кастовать к итератору.

Вывод. Т.е., описывая свой какой-то тип, можно заставить его работать как будто это классический итератор. Но здесь 
можно продумать более интересные сценарии.

Пример `Ex002`. Предположим, надо создать какой-то напиток, напр., кофе. Для приготовления кофе понадобится: зерна, вода, 
возможно молоко, сахар. Можно описать некоторый класс "напиток". Напиток будет содержать какие-то компоненты и дальше 
при помощи итератора будем пробегаться по этим самым компонентам и быть может с ними что-то делать. Быть может 
просматривать их, считать их калорийность.

Всё начинается с условного типа напиток/класс абстрактный `Beverage`. Но в то же время будет имплементировать итератор,
зависящий, или обобщение закрытое `Ingredient`-ом. Далее есть коллекция `components`. В конструкторе `Beverage()` будет 
производиться какая-то начальная настройка. Дальше будет метод добавления `addComponent` и реализация самого итератора: 
`hasnext()`, `next()`. Далее создаем конкретный напиток/класс `Coffee`, здесь с точки зрения реализации можно ничего не 
указывать потому что это сделано в базовом классе. Далее есть абстрактный `Ingridient` (класс). Он будет содержать 
условное наименование `brand`. Конструктор `Ingredient(brand)`, который быть может быть что-то указывать. И для красоты 
переопределение метода `toString()`. Далее есть конкретные ингредиенты: `Beans`, `Milk`, `Water`, которые показались 
очень нужными. Теперь с точки зрения клиентского кода:

    Beverage latte = new Coffee();
    latte.addComponent(new Water("Вода"));
    latte.addComponent(new Beans("Зёрна"));
    latte.addComponent(new Milk("Молоко"));

    Iterator<Ingredient> iterator = latte;
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }

Создаем напиток `latte` типа `Coffee`. Далее добавляем компоненты `latte.addComponents()`. Дальше с помощью итератора 
пробегаем по компонентам напитка.

Это был ещё один пример использования итератора. Как ещё использовать итератор зависит только от того нужно это, или 
нет? Здесь важный посыл заключается в том что представляется функционал и показывается как примерно это работает. Нужно 
это в коде, или нет - определяешь сам. Можно написать итератор с нуля, не используя встроенные интерфейсы. Если 
потребуется какая-то своя логика перебора этих своих компонентов - просто описываете её так как вам нужно. В общем 
случае, можно вообще не реализовывать этот интерфейс, тогда понятно что не будет работать какой-то стандартный 
функционал, но в то же время никаких проблем, чтобы описать какое-то собственное поведение. Если нужно работать с учетом 
каких-то синтаксических особенностей ЯП, в данном случае, `Java`, то говорят "делай так". Если хочешь как-то по своему -
"делай по своему". Хочешь, чтобы в рамках этого напитка был метод, который будет возвращать итератор? Пожалуйста, делай 
так. Это всё сильно ситуативно и главное понимание - какую задачу здесь решаешь?

`0:13:55`. Следующий пример. Если сейчас получаем итератор, используя методы: `hasNext()`, `next()`. Такая конструкция 
может показаться неудобной. Привыкли работать с конструкцией `foreach` потому что так удобнее и хочется сделать, чтобы 
перебирать компоненты с помощью `foreach`. Как этого добиться? 

Идем и пробуем описать логику в клиентском коде:

    for (String string: latte) {
    }

Вроде в логике было завязано на ингредиенте в классе `Beverage` - `Iterator<Ingredient>`, которые как-то кастовались в 
строки - класс `Ingredient` метод `toString()`. Но почему-то в клиентском коде этот цикл работать отказывается. Даже 
если заменить в цикле `String` на `Ingredient` - всё равно не работает.

    for (Ingredient string: latte) {
    }

А не заработало потому что, для того чтобы заставить работать с нашими описанными типами этот цикл `foreach` нужно 
реализовать некоторый иной интерфейс. `Ex004`. Напиток, класс `Beverage` будет имплементировать интерфейс 
`Iterable<Ingredient>`, который параметризирован `Ingredient`, или закрыт определенным типом.

> Если в `<>` не указывается определенный тип, то он открыт для любых типов.

Есть класс `Coffee` и здесь переопределение метода `iterator()` под себя. Далее, внутри метода описана логика метода как
было ранее с методами: `hasNext()`, `next()`.

В клиентском коде создаем экземпляр кофе `latte`. Кофе будет из воды. Далее циклом `foreach` можно перебрать компоненты.

    Coffee latte = new Coffee();
    latte.addComponent(new Water("вода"));
    latte.addComponent(new Water("вода"));
    latte.addComponent(new Water("вода"));
    
    for (var ingredient: latte) {
        System.err.println(ingredient);
    }

Далее внутри итератора, или механики добавления можно прописать логику того, что если тот компонент, который пытаемся 
добавить уже есть, то что делать? Его точно нужно добавлять? Или может принудительно запрещать? Вот именно саму механику
надо определять самому. 

Например, если понадобилось отсортировать коллекцию, наполненную нашими типами, по какому-то заданному нами правилу? 

В клиентском коде `Ex005`. Есть коллекция случайных чисел `numbers`. Сортируем `Collections.sort()`. 

    List<Integer> numbers = new ArrayList<>();

    for (int i = 0; i < 10; i++) {
        numbers.add(r.nextInt(1, 20));
    }

    System.out.println(numbers);
    Collections.sort(numbers);
    System.out.println(numbers);

Если наполнить коллекцию условными рабочими. Как понять что один рабочий больше другого? Ранее обсуждалось равенство 
двух объектов. Но как в то же время как сделать так, чтобы понять что один рабочий больше другого? 

По умолчанию сортировка хорошо работает для чисел. Как то же самое повторить для более сложных типов? Для этого 
наполнили коллекцию рабочих. В рабочих что-то прописано (поля). 

    List<Worker> db = new ArrayList<>();

    for (int i = 0; i < 5; i++) {
        db.add(new Worker("Имя" + i, "Фамилия" + i,
                r.nextInt(18, 31), r.nextInt(10000)));
    }
    System.out.println(db);

    Collections.sort(db);
    // Array.sort(...)
    System.out.println(db);

Вывод на экран коллекцию. Сортировка, используя `Collections.sort()`. "и внезапно почему-то сортировка произошла по 
возрасту". А произошло это потому что в рамках класса `Worker` есть имплементация `Comparable<Worker>`. Через `F12` 
можно узнать из документации, что он содержит единственный метод `compareTo()`. Переопределив этот метод в `Worker`, 
указать в методе информацию, что один рабочий больше другого по возрасту.

    @Override
    public int compareTo(Worker o) {
        if (this.age > o.age)
            return 1;
        else if (this.age < o.age)
            return -1;
        else return 0;
    }

В методе сравниваем текущий экземпляр с тем, который будет подсован. Логика простая. Если возраст текущего больше - 
возврат `1`, если меньше возврат `-1`, а если равны - `0`. Не нужно думать: почему так? Просто так описано в 
документации. Разработчики Java посчитали, что, чтобы сравнить по какому-то критерию надо свести сравнение этих 
интерфейсов по обычному критерию, например, чисел. 

Есть более простая логика сравнения. В данном случае идет сравнение чисел. 

> Как бы не стараться, но в конечном счете сравнение будет сводиться к сравнению примитивных типов: числа, строки, 
> символы.

У `Integer` есть метод `compare()`, в который передаем возраст текущего рабочего и `o.age`.

    @Override
    public int compareTo(Worker o) {
        return Integer.compare(this.age, o.age);
    }

Если понадобится изменить на другой критерий сортировки, напр., по зарплате, то поменять:

        return Integer.compare(this.salary, o.salary);

Но есть проблема. В конечном итоге чтобы была возможность изменения сортировки - описываем отдельную компоненту, 
отвечающую за упорядочивание рабочих - класс `SalaryComparator`. Здесь описываем логику как упорядочивать рабочих:

    public class SalaryComparator implements Comparator<Worker> {
        @Override
        public int compare(Worker o1, Worker o2) {
            return Integer.compare(o1.salary, o2.salary);
        }
    }

И тогда в клиентском коде можно сделать более хитрую реализацию. Можно указать `db.sort` и в момент определения, если 
присмотреться на подсказку `IDE`, то можно увидеть что просит передать какой-то `Comparator`. Можно добавить наш 
`SalaryComparator`:

    db.sort(new SalaryComparator());

Внимание! Если вдруг в рамках нашего не будет возможности имплементации интерфейса `Comparable<>`. Т.е. всё плохо. 
Тогда:
1. Описать свою отдельную компоненту, как `SalaryComparator`;
2. 

Это идут такие детали Java. Для чего они нужны? Что если читать документацию, то будем сталкиваться с конструкциями, с 
которыми в учебе не сталкивались. `0:22:52` Соответственно это будет вызывать определенные сложности. Поэтому взять 
`db`, есть `sort()`. В `sort()` в качестве аргумента передадим компаратор, но можно сделать это хитрее: добавить `w1`, 
`w2` и логику, которая значит сравнение двух объектов:

    db.sort((w1, w2) -> Integer.compare(w1.age, w2.age));
    db.sort(Comparator.comparingInt(w -> w.age));           // - совет IDE

Написали то как известно только лаконично. `IDE` предложило свой вариант. Не нужно описывать какой-то класс, не нужно 
имплементировать какие-то интерфейсы, а сделать одной строчкой. Можно задать сортировку по разным критериям:

    db.sort((w1, w2) -> Integer.compare(w1.salary, w2.salary));

Вывод. Здесь есть с одной стороны пул новых интерфейсов, с другой стороны какие-то языковые конструкции, которые в Java 
выглядят так, в других ЯП будут выглядеть по другому. Это не должно смущать. Механика будет +/- похожей.

Закончить лекцию можно примером, о котором была речь ранее - о напитках. Там было сказано, что абсолютно спокойно можно 
проверить является ли компонент, включен ли, если он включен тогда его не добавлять. Но здесь важным моментом является 
то, что обязаны описать определенные методы. Какие методы надо переопределить/перегрузить чтобы заработала проверка на 
включение тех, или иных компонентов? Если эти компоненты экземпляров являются достаточно сложных, или самописных типов.

Пример `Ex007`. Если с точки зрения логики всё предельно просто. Описываем добавление. Внутри ингредиентов должны 
выяснить: что значит и для чего нужен `equals()`? Переопределить `equals()` чтобы понять: что значит один ингредиент 
равен другому? Логика переопределенного метода: если бренды совпадают, значит больше его добавлять не нужно: 

    @Override
    public boolean equals(Object obj) {
        Ingredient t = (Ingredient) obj;
        return t.brand == this.brand;
    }

Как следствие, когда будем пробегать по напитку - будем проверять если по каким-то причинам в коллекции уже имеется 
такой же компонент, то делать ничего не нужно, а в противном случае добавить. 

Теперь, если в клиентском коде будем добавлять воду одного бренда то в напитке будет только одна порция воды. Если 
бренды будут разные: `вода1`, `вода2`, `вода3`- то будут добавлены. 

`0:26:25` В примере `Ex006` напоминается что есть разные способы сравнения объектов. Для `Worker1` будет прямое 
сравнение. Для `Worker2` сравнение будет через свою механику и т.д. Идея в том, что один экземпляр будет равен другому? 
Здесь в примере напоминается что `==`, `equals` и `compareTo` - это не одно и тоже. Одни механики нужны для определения 
один объект больше другого, т.е. для упорядочивания. Какие-то нужны для сравнения внутренних состояний. И есть 
классическое равенство `==`. Но если сравнивать конкретные ссылочные типы, то будут сравниваться ссылки на адреса 
памяти. Поэтому нужно быть внимательным. Если нужно сравнить два экземпляра, то нужно сравнивать, то что внутри, а не 
ссылки. 

Обязательно попробовать реализовать самостоятельно те, или иные интерфейсы. Какие-то были показаны, какие-то нужно 
"нагуглить", в зависимости от решаемых задач. В общем интерфейсов колоссальное количество. Все их никто никогда не 
расскажет, но у них +/- одинаковая механика абсолютно у всех с точки зрения реализации: имплементация интерфейса, а 
дальше читаем документацию "как он должен быть имплементирован?". В некоторых случаях можно увидеть "лямбды"- чтобы 
примерно представлять что это такое? В некоторых случаях можно увидеть анонимные классы. Соответственно, представляем 
как это работает? Как это делается с точки зрения синтаксиса ЯП Java. В других ЯП будет по другому. Может быть будет 
называться по другому, но идея будет +/- точно такая же. Это касается наиболее популярные ЯП.
