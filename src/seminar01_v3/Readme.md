### Проект торгового автомата в стиле ООП.

"Все в мире является объекты." И с этой мыслью приступать к задачам.

Начало с класса торгового автомата `VendingMachine` - это не базовый класс, а фабрика будущих объектов.

Поля для `VendingMachine`:
1. ассортимент `List<String>`. String не достаточно. Напр., написали "баунти", но хочется знать: размер шоколадки, 
стоимость, т.е. хочется более подробную инфу про товар;
2. 

Замечания по полям:
1. не стоит описывать что это автомат по торговле, напр., газировкой. Т.к. это уже будет какой-то наследник. Не будет 
изменять работу объекта. Просто какая-то наклейка;
2. 

Говоря про ассортимент, создаем класс `Product`.
Наследование нужно когда нужно расширять функционал.

Поля `Product`:
1. `name` - название продукта;
2. `price` - цена продукта;
3. артикул;
4. вес;
5. срок годности.

Пока полей: `name` и `price` достаточно для задачи.

Замечания по полям `Product`:
1. количество. Речь идет об объекте, говоря о количестве, то создаются экземпляры объекта, а надо описать про 1 объект;

Первый принцип ООП "инкапсуляция" говорит, что надо скрыть то, чего не нужно знать пользователям.

> Не использовать `static`! Будет снижение оценки. Использование `static` - уход от ООП. 

Используя `static`, получается что поле, или метод - это не часть объекта, а ООП это общение между объектами.
`public static void main(String[] args)` - `static` говорит, что не надо создавать объект для запуска этого метода, 
просто его запускаем. Применив `static` к полю, получится что поле `static String name` это общее для всех продуктов, 
оно будет существовать в единственном экземпляре. Изменение имени одного продукта повлечет изменение имени других 
продуктов. Эта переменная не будет у каждого объекта своя. То же самое методы, с `static` они будут глобальными. 
Пример, каждый продукт может сообщить об истекшем сроке годности. Чтобы обратиться к этому полю/методу, нужно искать в 
определенном классе.

`static` используется в ООП, она не вредна, но пока отложить её.

Класс `Main` - клиентский код. В клиентском коде создадим экземпляр продукта.

> Название класса с большой буквы, переменная с малой.

     Product product = new Product();

Теперь можно обратиться к полям продукта: `name`, `price`. Это плохо. Что если юзер может изменить название и цену 
продукта, напр., сделать цену отрицательной? Поэтому надо скрыть эти поля от юзера. Для этого есть модификаторы доступа:
`public`, `private`. 

> `private` - видимость только в текущем классе, а `public` - во всех.

`Конструктор` - метод, который создает объект текущего класса. Создав конструктор с аргументами: `name`, `price` - в 
клиентском коде нельзя создать экземпляр с помощью `Product product = new Product()`. 

> Если в классе нет никакого конструктора, то Java сама его создаст. У каждого класса обязательно должен быть 
> конструктор.

> Если 2 метода называются одинаково - это перегрузка метода. Но они должны чем то отличаться: набором аргументов, или 
> при одинаковом числе и типах аргументов, хотя бы один аргумент должен быть другого типа. Это нужно чтобы Java понимала
> какой именно нужно вызвать конструктор.

Конструктор нужен не только для создания экземпляра объекта, но ещё инициализация полей. 0:42:55

Переменные "примитивы" они пишутся с малой буквы: `int`, `double`, `boolean`, `float`, `char`.

А когда тип переменной пишется с большой буквы, напр., `String` - это какой-то класс, ссылочный тип. У него свое 
описание, методы, наподобие то, что  делаем в задании. Если написано так:

     private String name; // => name = null; (default)

- это означает что у такой переменной значение по умолчанию = `null`

У примитивов значение по умолчанию = 0, у булевых = Ложь:

     private double price; // => price = 0; (default)
     private boolean var1; // => var1 = false; (default)

След вариант создаст бесконечную рекурсию, вызов самого себя:

     public Product() {
        this();
     }

0:48:54




## sad

# 1
