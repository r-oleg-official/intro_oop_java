## Lecture 1. Введение в ООП. Свои типы и концепты.

Способ управления сложными системами: "Разделяй и властвуй".

Это значит, что программную систему нужно разбить на подсистемы так, чтобы работу каждой из них можно было
рассматривать и совершенствовать независимо от других.

Теперь снова надо будет рисовать блок-схемы только более сложные.

Сначала писали какой-то код и он как-то работал. Далее появилась тема методов. Теперь нужно было продумать код так,
чтобы он не был завязан на определенных данных. Напр., код для ввода с клавиатуры, или считывание с файла. Т.е. когда
была задача: сложить два числа, то это была задача не про сложение каких-то двух чисел, а речь про любые числа.

Получается были этапы:
1. писали код стихийно;
2. перешли к процедурному подходу: писали какие-то методы и функции;
3. объединение данных и методов над которыми работали.

Примерно так происходит эволюция перехода в **`Объектно-Ориентированное Программирование`** (`ООП`). Идея ООП родилась
давно, но до сих пор она актуальна.

#### Тезисы ООП:
1. Правильное пан-реализация только после абстракций;
2. Абстракция - что делает?
3. Поведение - как делает?
4. Спецификация - набор правил, описывающих API?

##### 1-й тезис.
Прежде чем начать писать код - надо сесть и подумать: что будешь писать?. Но! Подумать не по принципу: как
это будет работать? А что это будет вообще такое? Если разрабатываешь какую-то систему, напр., сложение двух чисел,
определяем: какие сущности будут в приложении, в системе? Если речь про складывание чисел, то сущность будет - число.
Это сильно просто. Но если будем работать с точками 2-хмерного пространства, тогда определяем отдельную сущность,
которая описывает структуру данных - точку. Как следствие, для точки справедливо для 2-хмерного пространства:
координата `х` и `у`. Всё ли это?

На след-м этапе надо подумать: а как печатать эту точку? Хочешь ил показать только координаты точки, или какой-то
красивый вывод? Напр., (х, у), (х; у), или {х:у}, или как-то по другому.

Какие операции справедливы для точки? Напр., для проектирования, для описания векторов.

> Когда проектируешь надо четко понимать: какую задачу решаешь?

Если явно не описано в функциональных требованиях к продукту, или в ТЗ что дальше будем работать с векторами. В таком
случае такое поведение закладывать не нужно. Если говорят, что работать с точками, описан перечень действий, который
нужно производить с этими точками, значит их и нужно описывать.

В данном случае, попробуем описать систему, которая позволяет объявить для начала точку и дальше, напр., вычислить
расстояние между двумя точками и красиво распечатать эту самую точку. Как это сделать?

##### 2-й тезис. Абстракция.
Когда описываешь какую-то систему, выделяя в ней отдельные сущности, нужно обдумывать ни как делает эта сущность, или
каким образом будет реализовывать тот или иной функционал? А для начала надо описать на уровне абстракции. Есть
какая-то сущность, может что-то делать. Как это делать - отвечает конкретный представитель. В частности, если
рассмотреть большое семейство котиков. Для любого котика справедливо у него есть: лапки, кличка, высота полки, окрас
шерсти и т.д. Напр., возьмем кота: шотландский вислоухий, серого цвета, у него голубые глаза.

Вот это разделение и есть общие абстракции, когда речь про: окрас шерсти, высота полки, кличка. И в то же время
конкретное состояние, в данном случае: серый окрас шерсти, голубые глаза и т.д.

Дальше когда речь о проектировании, нужно четко понимать какими состояниями и поведениями обладает та, или иная
сущность. Если говорить о котике. Под состояниями можно понимать: высота полки, окрас шерсти, кличка, порода. А под
поведением можно понимать котик может: спать, кушать, бегать, прыгать, баловаться и т.д. То же самое справедливо для
любой сущности, системы, которая будет описываться. Для начала концентрируемся на объявлении на конкретных таких
сущностей. Далее ждут проекты целых сервисов и надо будет переходить на след.-й уровень абстракции когда нужно
продумать о том как же, или что же, или каким образом будет делать тот, или иной сервис.

Допустим, надо написать соцсеть "вконтакте". Нужно четко понимать, что в ней должен быть функционал воспроизведение
песен, видео, отправка сообщений, наличие стены. И дальше, исходя из этого, начинаешь разрабатывать.

Для того чтобы описать возможность прослушивания музыки - нужна сущность "песенка". У песенки есть длительность,
битрейт, название, исполнитель, год исполнения.

> У песенки есть деятельность 0:08:25.

Таким образом, от самого большого будешь спускаться все, все меньшему, меньшему, к каким-то системным единицам.

> Абстракция отвечает на вопрос: что именно делает та, или иная сущность? А конкретным поведением обладает конкретный
> экземпляр, или представитель вот этой самой сущности.

##### 4-й тезис. Спецификация.
Спецификация - набор правил, описывающих API. Но что же такое `API`? Ранее говорили, набор методов, их конкретное
действие, наименование этих методов, или описание этих методов должны быть понятны конечному потребителю нашего
сервиса, использование наших сущностей, библиотеки и т.д.





## 11

## 22

## 33
