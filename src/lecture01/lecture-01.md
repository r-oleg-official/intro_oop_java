## Lecture 1. Введение в ООП. Свои типы и концепты.

Способ управления сложными системами: "Разделяй и властвуй".

Это значит, что программную систему нужно разбить на подсистемы так, чтобы работу каждой из них можно было
рассматривать и совершенствовать независимо от других.

Теперь снова надо будет рисовать блок-схемы только более сложные.

Сначала писали какой-то код и он как-то работал. Далее появилась тема методов. Теперь нужно было продумать код так,
чтобы он не был завязан на определенных данных. Напр., код для ввода с клавиатуры, или считывание с файла. Т.е. когда
была задача: сложить два числа, то это была задача не про сложение каких-то двух чисел, а речь про любые числа.

Получается были этапы:
1. писали код стихийно;
2. перешли к процедурному подходу: писали какие-то методы и функции;
3. объединение данных и методов над которыми работали.

Примерно так происходит эволюция перехода в **`Объектно-Ориентированное Программирование`** (`ООП`). Идея ООП родилась
давно, но до сих пор она актуальна.

#### Тезисы ООП:
1. Правильное пан-реализация только после абстракций;
2. Абстракция - что делает?
3. Поведение - как делает?
4. Спецификация - набор правил, описывающих API?

##### 1-й тезис.
Прежде чем начать писать код - надо сесть и подумать: что будешь писать?. Но! Подумать не по принципу: как
это будет работать? А что это будет вообще такое? Если разрабатываешь какую-то систему, напр., сложение двух чисел,
определяем: какие сущности будут в приложении, в системе? Если речь про складывание чисел, то сущность будет - число.
Это сильно просто. Но если будем работать с точками 2-хмерного пространства, тогда определяем отдельную сущность,
которая описывает структуру данных - точку. Как следствие, для точки справедливо для 2-хмерного пространства:
координата `х` и `у`. Всё ли это?

На след-м этапе надо подумать: а как печатать эту точку? Хочешь ли показать только координаты точки, или какой-то
красивый вывод? Напр., (х, у), (х; у), или {х:у}, или как-то по другому.

Какие операции справедливы для точки? Напр., для проектирования, для описания векторов.

> Когда проектируешь надо четко понимать: какую задачу решаешь?

Если явно не описано в функциональных требованиях к продукту, или в ТЗ что дальше будем работать с векторами. В таком
случае такое поведение закладывать не нужно. Если говорят, что работать с точками, описан перечень действий, который
нужно производить с этими точками, значит их и нужно описывать.

В данном случае, попробуем описать систему, которая позволяет объявить для начала точку и дальше, напр., вычислить
расстояние между двумя точками и красиво распечатать эту самую точку. Как это сделать?

##### 2-й тезис. Абстракция.
Когда описываешь какую-то систему, выделяя в ней отдельные сущности, нужно обдумывать ни как делает эта сущность, или
каким образом будет реализовывать тот или иной функционал? А для начала надо описать на уровне абстракции. Есть
какая-то сущность, может что-то делать. Как это делать - отвечает отдельный конкретный представитель. В частности, если
рассмотреть большое семейство котиков. Для любого котика справедливо у него есть: лапки, кличка, высота полки, окрас
шерсти и т.д. Напр., возьмем кота: шотландский вислоухий, серого цвета, у него голубые глаза.

Вот это разделение и есть общие абстракции, когда речь про: окрас шерсти, высота полки, кличка. И в то же время
конкретное состояние, в данном случае: серый окрас шерсти, голубые глаза и т.д.

Дальше когда речь о проектировании, нужно четко понимать какими состояниями и поведениями обладает та, или иная
сущность. Если говорить о котике. Под состояниями можно понимать: высота полки, окрас шерсти, кличка, порода. А под
поведением можно понимать котик может: спать, кушать, бегать, прыгать, баловаться и т.д. То же самое справедливо для
любой сущности, системы, которая будет описываться. Для начала концентрируемся на объявлении на конкретных таких
сущностей. Далее ждут проекты целых сервисов и надо будет переходить на след.-й уровень абстракции когда нужно
продумать о том как же, или что же, или каким образом будет делать тот, или иной сервис.

Допустим, надо написать соцсеть `VK`. Нужно четко понимать, что в ней должен быть функционал воспроизведение
песен, видео, отправка сообщений, наличие стены. И дальше, исходя из этого, начинаешь разрабатывать.

Для того чтобы описать возможность прослушивания музыки - нужна сущность "песенка". У песенки есть длительность,
битрейт, название, исполнитель, год исполнения.

> У песенки есть деятельность 0:08:25.

Таким образом, от самого большого будешь спускаться все, все меньшему, меньшему, к каким-то системным единицам.

> Абстракция отвечает на вопрос: что именно делает та, или иная сущность? А конкретным поведением обладает конкретный
> экземпляр, или представитель вот этой самой сущности.

##### 4-й тезис. Спецификация.
Спецификация - набор правил, описывающих API. Но что же такое `API`? 

`API` - как ранее говорили, набор методов, их конкретное действие, наименование этих методов, или описание этих методов 
должны быть понятны конечному потребителю нашего сервиса, использование наших сущностей, библиотеки и т.д.

Т.е. здесь сначала нужно исходить из того что у нас будет соцсеть `VK`, у неё будет:
1. отправить сообщение;
2. прослушать песню;
3. просмотреть видео и все.

А дальше начинается идея, что вот в этот функционал, в эту спецификацию продумываете какие-то сервисы в более широком 
представлении. 

После того как определили, как будут называться, как будут описываться сервисы, будете подгонять отдельные сущности, 
напр., ту же сущность `трек`, или если говорить напр., о проектировании достаточно больших систем, даже казалось бы 
самая простая идея песни/трека - она может содержать в себе большое кол-во артистов. А артист - отдельная сущность. 
Потому-что у артиста есть:
1. фамилия;
2. имя;
3. может быть наименование альбома;
4. и т.д.

Т.е. разбирая большую казалось бы систему на такое маленькое количество на абсолютно тривиальных таких сущностей.

Пока может показаться эта информация непонятной, или может быть непонятно как применять эту информацию? Но надо 
набраться терпения, к концу курса все встанет на свои места. 

> Когда речь идет об объектно ориентированном подходе - ваша задача: мыслить теперь уже не просто какими-то переменными,
> какими-то циклами, или какими-то методами. Задача мыслить классами и конкретными представителями этих классов, т.е 
> экземплярами классов.

#### Класс

**Класс** - это `чертеж` (описание) сущности предметной области, позволяющий выделить некоторые общие характеристики, 
состояние и поведение, зависящее от состояния.

Вспомнить: что относится к классу, что к поведению, что к состоянию?

Далее большой "пласт" - `экземпляры класса`.

#### Экземпляр класса
**Экземпляр класса** - отдельный представитель класса, имеющий КОНКРЕТНОЕ состояние и поведение, которое полностью 
определяется описанием класса.

Напр., если есть класс `котики`, то конкретный "Барсик" - это и есть тот самый конкретный экземпляр класса.

Очень часто экземпляр класса отождествляют с понятием объекта. 

> Для "джуна" - это довольно нормальное поведение. Но если идешь на собеседование выше +- средний миддл, то все-таки 
> надо немножко разделять. К концу курса станет известно отличие.  0:11:30

После того как узнали что есть классы, экземпляры классов, теперь нужно понимать чем наполнять эти самые классы.

**Экземпляр класса**:
1. состояние:
   - поля
   - константы
   - события
2. поведение:
   - конструкторы
   - методы

> В поведении класса в общем случае больше 2-х пунктов, но пока оставим как есть.

На данном этапе из состояний достаточно `поля`, а из поведений: `конструкторы` и `методы`. Пока этого хватит.

**ООП** - Объектно-Ориентированное Программирование. 0:12:11

Парадигма (стиль, шаблон) разработки ПО, основными понятиями которой являются классы и объекты. Говорят, что разработка 
в стиле ООП ведется с использованием классов объектов, которые обладают состоянием и поведением, зависящим от этого 
состояния.

По другому, объектно-ориентированный подход - это попытка мыслить, или проектировать системы с использованием этих 
самых классов и экземпляров этих самых классов, но ещё говорят "и объектов".

#### Код на примере вычисления координат 2-хмерного пространства.
      public class PointMethodEx001 {
         static double distance(int x1, int y1, int x2, int y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
         }

         public static void main(String[] args) {
           int ax = 0;
           int ay = 0;
           int bx = 0;
           int by = 1;
           System.out.println(distance(ax, ay, bx, by));
      //   Создать точку
      //   Печать точки
         }
      }

Начнем издалека, используя "стихийный подход" в программировании, т.е. определяем точку 2-хмерного пространства. У 
точки есть две координаты. Есть одна точка `a` координата (х и у) и другая точка `b` с координатой (х и у). Далее 
описываем `а(х)`, `а(у)`, присваиваем какие-то значения. Дальше есть `b(х)`, `b(у)`, присваиваем какие-то значения.
Далее описываем метод, напр., `distance()`, который принимает эти 4-е аргумента и считает расстояние между точками.

Можно пойти другим путем. Представить каждую точку массивом/коллекцией или чем-то другим. Технически возможно. Но сути 
дела это особо не меняет. 

Это был "стихийный подход", в котором были описаны 4-е координаты. Дальше есть какой-то метод `distance()`, считающий 
расстояние и дальше результат как-то используется. Это "стихийный подход" (набор переменных)с приправленный процедурным 
(набор методов). 

Технически, можно было сделать чтобы метод возвращал пару чисел, которая представляла собой точку и т.д., но оставим 
как есть.

Так вот, когда идет речь о попытке перехода в контекст объективно-ориентированного подхода, то нужно выделить сущность 
"точка".

Point2D.java:

      public class Point2D {
         int x, y;
      }

PointMethodEx002.java:

      public class PointMethodEx002 {
         static double distance(Point2D a, Point2D b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2)); 
            // ошибка в лекции: 1- b(x)-a(x); 2- a(x)-b(x)
         }
      
          public static void main(String[] args) {
              Point2D a = new Point2D();
              a.x = 0;
              a.y = 2;
              System.out.println(a.toString());
      
              Point2D b = new Point2D();
              b.x = 0;
              b.y = 10;
              System.out.println(b.toString());
              System.out.println(distance(a, b));
          }
      }

Есть класс `Point2D`, для которого определены 2-е точки. Эти самые `x` и `y`, которые раньше назывались переменными, 
теперь они наз., `полями`. 

> Какая-то переменная в контексте класса наз. - полем.

Это ни хорошо, ни плохо, просто это так.

Теперь логику можно описывать след образом. Раньше в метод передавались 4-е аргумента, что-то себя представляющие. 
Теперь есть метод, который принимает 2-е точки. Переходим на след уровень абстракции. Есть какая-то точка `a`, а у 
точки `a` есть какие-то: `x` (a.x), `y` (a.y); с которыми дальше пытаемся манипулировать.

Дальше определяем "представителя", или "экземпляр" класса.

      Point2D a = new Point2D(), 
где, `Point2D` - класс, `a` - экземпляр класса, `a.x = 0` - значения нужных полей, `new Point2D()` - конструктор класса. 

Вычисление происходит с помощью метода `distance(a, b)`, в который передаются 2-е точки.

> Класс - это описание каких-то общих характеристик. 

> `a` и `b` - экземпляры класса. Конструктор создает новый экземпляр данного класса.

> Память. `a` будет размещаться в `STACK`, а всё остальное в куче `HEAP`. Это грубое объяснение.

Пока не вызовешь `конструктор класса`, непонятно где хранить те самые `x` и `y`.

Так что надо запомнить и вспомнить тот материал, в котором рассказывалось на примере работы с кучей и то, как можно 
получить неприятные ситуации.

Итог. Мы описали некую сущность "точка". Можно сказать что в точку `инкапсулировали` значения координат (х и у) точек. 
Но попробуем наполнить созданный класс каким-то доп `поведением` и попробуем что-то описать.

Для `поведения` существуют: конструкторы и методы. 0:16:03.

Допустим, не хочется писать след образом:

      a.x = 0;
      a.y = 2;

Хочется вызвать конструктор и передать 0 и 2 след образом:

      Point2D a = new Point2D(0, 2);

Теперь такое поведение добавить в класс `Poind2D`. Если у нас есть поля `x` и `y`. Надо описать некоторый конструктор, 
можно использовать сниппет `ctor` (в `IDEA` не работает). 

> В `IDEA` пр. кл. мыши -> Generate... Alt+Ins -> Constructor.

Point2D.java:

      public class Point2D {
         int x, y;

         public Point2D(int valueX, int valueY) {
            x = valueX;
            y = valueY;
         }
      }

`public Point2D()` похож на метод, но это не метод, т.к. нет возвращаемого эл-та (int/String...)

Далее, пусть будут некоторые значения, напр., `int valueX`, `int valueY`, описываем это как будто это обычные аргументы.
Далее присваиваем: `x = valueX`, `x = valueY`. 

Теперь появляется возможность в клиентском коде передавать значения `x, y` как аргументы в конструктор. 

> Клиентский код - код, в котором создают сущность, через конструктор, напр., `Point2D a = new Point2D()`.

Задача выполнена. Теперь создавать точку надо так:

      Point2D a = new Point2D(0, 2);

Но конструктор `new Point2D()` теперь недоступен. Почему нельзя использовать? Т.е. пытаешься что-то делать по умолчанию,
то есть поведение по умолчанию. 

> Конструктор у которого нет аргументов, наз., конструктором по умолчанию. Технически можно написать свой конструктор 
> по умолчанию, для того чтобы описать поведение.

Если же начинаешь описывать пользовательский конструктор (как раз то что сделали), то в этом случае всё что было до него
по умолчанию оно как бы испаряется. Поэтому можно описать ещё конструктор, работающий с иной логикой. Для этого 
перейдем в класс `Point2D` и добавим ещё один конструктор, можно через сниппет `ctor`. Пока без параметров.

> В `IDEA`: Generate... -> Constructor, далее в нем сразу нажать кнопку `Select None`.

      public class Point2DEx003 {
         public Point2DEx003() {
         x = 0;
         y = 0;
         }
      }

Т.е. в конструкторе мы переопределяем `x` и `y`, равные нулю. Технически здесь в конструкторе можно объявить какое-то 
свое поведение, т.е. пусть `x = 10`, `y = 28`. Можно? Да, можно. Правильно ли это поведение? Нет, неправильное в данном 
случае.

Хорошо, помимо этого можем сказать: а давайте пусть конструктор принимает 1 аргумент, напр., `value`. В `x` и `y` будем 
ложить `value`. 0:18:54

      public class Point2DEx003 {
          public Point2DEx003(int value) {
              x = value;
              y = value;
          }

Т.е., если потребуется описать точку, которая будет `а(10, 10)`. Можно описать топорно:

      a.x = 10;
      a.y = 10;

или 

      Point2D a = new Point2D(10, 10);

Но теперь можно еще и так:

      Point2D a = new Point2D(10);

Доступно два варианта создания экземпляра класса.

Сейчас, когда пытаешься распечатать на экране точку `a`, то можно увидеть какую-то чепуху:

      System.out.println(a);
      // lecture01.Point2DEx003@5acf9800

Что это значит? Это значит, что по умолчанию у нашего класса `Point2D`, `Point2DEx003` и т.д. есть какое-то свое 
поведение, отвечающее за преобразование этой точки в строку. Значение по умолчанию определяется методом `toString()`.

Т.е. технически когда в `System.out.println()` передана аргументом точка в виде `a`, автоматически вызывается метод 
`a.toString()`.

      System.out.println(a.toString());

Правильно это поведение? Технически нет. Нам это не совсем удобно. Можно описать отдельный метод, который будет 
показывать точку так как нам нужно. Пусть это будет метод `getInfo()`, возвращать будет `String`, пока указать `public`.

> Наперед забегая, `public` - это модификатор доступа.

      System.out.println(a.getInfo());

      public class Point2DEx003 {
          public String getInfo() {
              return String.format("x: %d; y: %d", x, y);
          }
      }

Если, напр., сделать след образом, то `a` нормально, а `b` нет:

      System.out.println(a.getInfo());
      // x: 0; y: 2
      System.out.println(b.toString());
      // lecture01.Point2DEx003@279f2327

> Все что было написано до нас, можно переделать под себя. Это называется "переопределением метода".

Если есть метод `toString()` и он показывает непонятно что, то можно переопределить поведение метода под себя. Для 
этого начинаешь писать `to` и, напр., `IDEA` подскажет `public String toString()   Object`. 0:22:39. 
Важным моментом здесь является `@Override`. В методе `public String toString()`, который с `@Override` заменим 
возвращаемое значение с `super.toString()` на `getInfo()`.

    public class Point2DEx003 {
       @Override
       public String toString() {
           return getInfo();
       }
    }

Теперь если пойти в клиентский код и запустить, то внезапно, передавая аргумент `b` в `System.out.println()` получим 
отображение точки в консоли в нужном виде.

    System.out.println(b);
    // x: 10; y: 10

Если заметить, то метод `getInfo()` по большому счету не нужен - его возвращаемое значение поместить в возврат метода 
`public String toString()` с `@Override`. Но Сергей сделал это для демонстрации идеи использования модификаторов 
доступа. 

#### Модификаторы доступа
1. Если стоит модификатор доступа `public`, то по умолчанию считается что этим методом, или членом класса можно 
пользоваться откуда угодно, т.е. любой может получить к нему доступ. 
2. Если метод пометить как `private`, то он будет доступен только внутри того класса, где его описывать и где его в 
дальнейшем можно будет использовать.

Если у метода `getInfo()` модификатор доступа заменить на `private`, то при вызове:

    System.out.println(a.getInfo());
    // java: getInfo() has private access in    // Error

До этого метода не получится достучаться. При попытке запустить ждет ошибка компиляции 
`java: getInfo() has private access in`. В `IDEA` метод будет подчеркнут красной волнистой чертой, если навести курсор 
мыши на метод, или нажать `Alt + Enter` (Show Context Actions) можно прочесть то же самое и рекомендации по исправлению.
Или в `VS Code` может при наведении на метод появится подсказка и в ней `"...method getInfo()... is not visible"`. 
Теперь метод `gedtInfo()` недоступен для внешних агентов, или клиентов, в нашем случае для клиентского кода.

> Помимо, кроме методов которые описываем сами, в некоторых случаях в контексте ООП, приходится переделывать за кем-то.

Здесь, напр., `toString()` был написан разработчиками Java. Допустим, мы сказали что не подходит и сделали так как 
нужно, добавив `@Override`. Тем самым переопределили поведение метода, которое было сделано кем-то до нас. Это 
справедливо как для стандартных методов, которые использовали, описывали разработчики Java, так и для ваших коллег.
Если написали сегодня какую-то библиотеку, те которые придут после нас, будут использовать такое переопределение 
стандартного функционала через `@Override`. 

Но. В большинстве случаев когда разработчики между собой общаются, они понимают значение слова `переопределение` и в 
некоторых случаях `перегрузка`. И, как правило, они понимают это одно и тоже, или из контекста понятно о чем идет речь.
Сергей говорит, что в рамках лекции он может спокойно не заметить что говорит термин `переопределение` или `перегрузка` 
какого-то метода. Лучше сразу разобраться и запомнить.

> __*Переопределение*__ - это изменение поведения метода, которое было до меня. Было какое-то поведение в рамках 
> старого класса/сущности. Дальше его переопределил под себя в рамках новой сущности. Обязательно `@Override`.

> __*Перегрузка*__ метода. Он, как правило, справедлив для ЯП: Java, C#, Swift, ну и на самом деле для многих ЯП это 
> определение применяется.

Так вот перегрузка говорит о том, что вы описываете в рамках одной сущности методы, отличающиеся сигнатурой.

> __*Сигнатура*__ - с лат. *signatura*, "обозначение".

Когда есть один метод и в нем напр., изменяется кол-во аргументов, или тип данных этих аргументов - это и есть те самые 
перегрузки методов. 0:26:14.

В нашем примере, когда были 2 метода с одним названием `distance`, но один принимал аргументы (`int x1`, `int y1`, 
`int x2`, `int y2`), а другой (`Point2D a`, `Point2D b`).

> Внимание! В некоторых ЯП, в частности в Java, нельзя делать перегрузку по имени аргументов.

Например:

    static double distance(int x1, int y1, int x2, int y2) {}
    static double distance(int a, int b, int c, int d) {}
    // don't work

В примере 4 аргумента с сигнатурами `int` и возвращаемым значением `double`. Даже если менять имена аргументов, все 
равно Java будет ругаться и не пропустит такой финт. Заработает, если уменьшить кол-во аргументов, изменить тип одного 
из аргументов, или тип возвращаемого значения метода:

    static double distance(int a, int b, int c) {}
    или
    static double distance(int a, int b, int c, Double d) {}
    или    
    static int distance(int a, int b, int c, int d) {}
    // work

> Есть такие ЯП где допускается перегрузка по имени аргументов, напр., `Swift`.

Если вернуться к примеру с классу `Point2D`, то были перегрузки только в контексте конструкторов.

    // Конструктор с 2-мя аргументами
    public Point2DEx003(int valueX, int valueY) {
    x = valueX;
    y = valueY;
    }

    // Конструктор без аргументов
    public Point2DEx003() {
        x = 0;
        y = 0;
    }

    // Конструктор с одним аргументом
    public Point2DEx003(int value) {
        x = value;
        y = value;
    }

Таким образом, имея понятия конструктора и методов, понимаете сколько здесь можно всякого творить. Можно описывать 
разные конструкторы, т.е. делать перегрузку этих конструкторов, в том числе можно использовать базовое поведение, 
которое было до нас. Есть методы, которые мы сами описываем и те, бывшие до нас, тоже можно переопределять. В то же 
время все это можно миксовать: взять старый метод, добавить к нему новое поведение. Или сделать перегрузку этих методов 
и т.д. 

Вроде бы все понятно, но Сергей рассказывал про `"don't repeat yourself"` (не повторяйся). Если посмотреть на код 
`Point2D.java`, поведения точки в описании не сильно то отличаются, отличие - разное количество аргументов.

В нашем случае, делаем инициализацию только 2-х аргументов `x` и `y`. А что если у нас будет котик у которого будет 
целый набор аргументов? Получается надо будет описывать 4-е конструктора в которых будет 10 строчек одних и тех же? Это 
неправильно. Для этого есть возможность пере-использования ранее описанных конструкторов. Используем максимально 
"широкий" конструктор, т.е. подразумеваем использование максимальное количество аргументов. `0:29:23`.
Вместо методов `public Point2D` с одним и двумя аргументами можно описать метод с одним аргументом `int value`, вместо 
`super()` написать:

    public Point2D(int value) {
    this.x = value;
    this.y = value;
    }

Это равноценно предыдущему варианту с `x = value`, `y = value`. 

> `this.x` - означает что пытаешься найти поле `x` в рамках текущей сущности/класса.

Но что если будем использовать `this.` с конструктором, описанным ранее:

    public Point2D(int valueX, int valueY) {
        x = valueX;
        y = valueY;
    }

    // Конструктор с this
    public Point2D(int value) {
        this(value, value);
    }

Вызывая конструктор `Point2D` с одним аргументом, на самом деле будет вызываться конструктор с 2-мя аргументами.

Дальше можно описать конструктор без аргументов, т.е. переопределить конструктор по умолчанию, теперь есть возможность 
вызова конструктора с одним аргументом, или с 2-мя:

    public Point2D(int value) {
        this(value, value);
    }

    // Конструктор по умолчанию с одним аргументом
    public Point2D() {
        this(0);
    }

    // Конструктор по умолчанию с одним аргументом
    public Point2D() {
        this(0, 10);
    }

Случай с конструктором по умолчанию с одним аргументом будет каскад вызовов:
1. `Point2D()`, далее передается управление с одним параметром через `this(0)`;
2. `Point2D(int value)`, далее вызывается конструктор с 2-мя аргументами через `this(value, value)`;
3. `Point2D(int valueX, int valueY)`, производим инициализацию, `x = valueX`, `y = valueY`;
4. возвращаемся в `Point2D(int value)`;
5. возвращаемся в `Point2D()`. 

`0:31:24`

Таким образом, начинаем придерживаться принципу `dry`. 

> Принцип `dry` говорит о том, что написали один раз "четкий" код, а дальше будем его использовать ровно так как нам 
> это нужно. Т.е. подставляем конкретные значения, а Java, или другой ЯП пусть сам разбирается как это сделать.

В ЯП C# такое тоже возможно. В других ЯП не факт, что такая возможность есть, поэтому надо быть внимательным.

#### Следующий момент. Защита полей.
Метод `getInfo()` пусть останется, но технически он не нужен. Подумаем над интересным моментом: определили точку 
`new Point2DEx004(0, 2)`, передав конкретные значения (0, 2). Дальше начинаем работать с этой точкой. Но! Внезапно 
приходит какой-нибудь жулик и начинает в нашем коде что-то писать, что писать на самом деле нельзя. Напр., он берет и 
говорит: а давайте мы в точку `а(х = -20)`? Хорошо ли это поведение? Должна ли у нас быть возможность изменения таким 
образом у конкретной точки конкретной координаты? Технически, да, можно сказать: может быть. 

Теперь представим ситуацию, когда описываем игру, в которой создается какой-то персонаж. Персонаж по умолчанию должен 
иметь уровень 1. Но приходит жулик, включает `Artmoney` и говорит: а теперь по умолчанию будет персонаж 100-го уровня.
Правильно ли это поведение? 

Следующий сценарий. Создается игра. На старте игры дается 600 золота, чтобы произвести какую-то закупку. Но внезапно, 
снова запускается какая-то программа/скрипт, который "идет" в наш код и аккуратно подменяет то значение `600` на `6000`.
Таким образом, персонаж 1-го уровня превращается в персонаж 100-го уровня, персонаж 600-та золотых монет превращается в 
персонаж 6000-и золотых монет. Правильно ли это поведение?

Нет, это неправильно! Получается надо придумать функционал, который поможет избавиться от таких "детских болячек".

Если перед полями не стоит никакой модификатор доступа, то считается по умолчанию `public`.

    public class Point2DEx005 {
      private int x, y;    // default public
    }

В текущем состоянии, в клиентском коде не сработает `a.x = 14;`. Но в то же время и прочитать не сможем координаты. 
Правильно ли поведение? Нет, неправильно.

В некоторых случаях может потребоваться прочитать значение конкретной координаты. Т.е., да действительно есть 
возможность использования `a.toString()`, но зачем `toString()`? Потом парсить строку, если я хочу показать:

    System.out.println(a.x);

Сергей говорит, что сейчас нет возможности, полностью закрыт доступ к этому аргументу (полю `x`). Как его (доступ) 
получить? Для этого можно в рамках нашей сущности описать метод и разграничить права доступа. 
1. если получаем целочисленную координату, то можно начать писать в `IDEA` `pu`, а дальше выбрать подсказку `public int 
getX() {...}`;


     public int getX() {
         return x;
     }

Аналогичным образом

     public int getY() {
         return y;
     }

Теперь в рамках клиентского кода у нас есть отдельный метод, возвращающий координату `x` - `getX()` и отдельный метод, 
возвращающий координату `y` - `getY()`. Как понимаете, возможности изменить значения этого поля нет. Но, если вдруг 
потребуется в какой-то момент такая возможность, то идем в исходный класс и дополняем его новым поведением. В нашем 
случае это будет - изменить координату `x`, или `y`, или изменить обе.

> Внимание! Когда делаешь `a = new Point2D()` далее по коду, то фактически создаешь новую точку, размещая в новом 
> участке памяти. И все что было до этого теряется. И это иное поведение и это будет являться неправильным в контексте 
> текущего объяснения.

Переходим в исходный класс `Point2DEx005()` и дополняем поведением: `изменить координату Х`, `изменить координату Y`.

Для этого начинаем писать в `IDEA` `pu` и выбираем подсказку `public void setX(int x) {...}`.

    public void setX(int value) {
        this.x = value;
    }

    public void setY(int value) {
        this.y = value;
    }

Нужно обязательно писать этот `this.`? Нет, не нужно. Но потихоньку надо привыкать потому что в больших системах надо 
понимать в какой момент работаешь с текущими полями, а в какой момент с полями, так сказать базовых классов.

Теперь в клиентском коде, с помощью `a.setX(12)` есть доступ к записи значения координаты точки `a` на `12` и доступ к 
чтению:

      a.setX(12);
      System.out.println(a.getX());

Таким образом разграничили права доступа. Отдельный функционал отвечает за изменение и отдельный за чтение данных. 

> Ещё эти методы называют `сеттеры` и `геттеры`. 

Нужен этот функционал всегда? Нет, не нужно. Но в некоторых случаях надо четко выделять: для этого будем только чтением 
заниматься, а вот для этого будем только записью заниматься. 

Пример. Есть сущность `account`, для аккаунта есть `username` и есть `password`. Естественно, пароль должен видеть 
никто по большому счету, но его можно изменить. А для никнейма: его видят все, но его никто не должен менять, или его 
нельзя изменить. Вот ещё одно поведение.

#### Документация. 0:37:41
Сергей всегда за описание документации, но здесь надо смотреть как работают в команде. Если посыл "нужно делать" - 
делаем, если "не нужно", то всё равно делаем только втихаря. 

Напр., обычный комментарий, особенно начинающие так делают:

      public class Point2D {
         private int x, y;    // Это координата х и у.
      }

Такие комментарии не нужно писать. Теперь нужно описывать что делает метод, класс, что делает этот конкретный кусок 
кода. 

Описание класса. Строкой выше начинаем `/**`, VS Code дополнит концовку `*/` - это границы блока комментария. В `IDEA`
`/**`, далее `Enter` - авто генерация концовки комментария. Можно пропустить до комментария 2 пустые строки.

    /**
    * Это точка 2D
    */
    public class Point2D {
        private int x, y;    // Это координата х и у.
    }

Описание конструктора с 2-мя аргументами. Также `/**` + `Enter` - получится:

    /**
     * Это конструктор ...
     * @param valueX это координата X
     * @param valueY это координата Y
     */

Теперь наводя курсор мыши в клиентском коде на конструктор `Point2D(0, 2)` можно увидеть подсказку из документации, 
написанную ранее в классе `Point2D`. Это окно с подсказкой называется `Intellisensional`. Таким образом создается 
собственная документация. Правильный ли этот результат? Сергей говорит, что в его практике - правильный. Даже если 
отказаться от документации в какой-то момент, сгрузится в какой-то отдельный файл. Потом при необходимости можно будет 
восстановить что там и как?

В некоторых случаях будут говорить что код должен быть самодокументированным. С одной стороны и это правильно, но 
нельзя забывать про документацию. Технические писатели точно скажут спасибо за документацию.

#### Что такое static 0:40:16
До этого выяснили что есть классы и экземпляры классов. Что такое `static`? Теперь в клиентском коде можно определить 
как `Point2D`, дальше написать `.distance()` и аргументами передать наши точки `a` и `b`. 

    public class Point2DEx005 {
       static double distance(Point2DEx005 a, Point2DEx005 b) {
           return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2)); // ошибка в лекции: 1- b(x)-a(x); 2- a(x)-b(x)
    }

    public class PointMethodEx005 {
      
      Point2DEx005.distance(a, b);
    }

> Теперь метод `distance()` перемещен из клиентского кода в класс. Сергей не показал перенос метода, код не 
> компилировался пока метод, был в клиентском коде.

Раньше функционал, который был в каком-то непонятном методе в рамках класса `PointMethod`, теперь этот функционал 
вынесен отдельно в соответствующую сущность `Point2D`, т.е. точки. Все что имеет к нему отношение - пусть там и 
валяется.

    public class PointMethodEx005 {
      var dis = Point2DEx005.distance(a, b);
      System.out.println(dis);
    }

#### Вывод.
Итак, посмотрели что такое классы, экземпляры классов. Если есть `static` +- нужно обращаться через имя типа 
(внимательно!), не через конкретный экземпляр, т.е. `Point2D a =` - где `a` - конкретный экземпляр, `Point2D` - тип. 
Соответственно, для статических членов обращаемся через имя типа.

### Концепты ООП. Инкапсуляция. 0:42:20
Дальше задача разобраться с концептами ООП и начнется с `инкапсуляции`. Первый принцип ООП - инкапсуляция.

_**Инкапсуляция**_ - это свойство системы, позволяющее объединить данные и методы, работающие с ними в классе, скрыв 
детали реализации и защитив от пользователя этого класса объектов.

В самом простом представлении инкапсуляции - объединение данных и логики обработки этих данных плюс сокрытие деталей 
реализации. Что это значит? Когда описывали точку, внутри была куча всякого, напр., как выводить точку на экран? 
Описали метод `getInfo()`, затем сделали переопределение `toString()` и т.д. Всё это есть детали реализации и каким 
образом это реализовано? Зачем там описаны 3 конструктора, которые друг друга вызывают? Это есть не что иное, как 
сокрытие деталей реализации. 

#### Робот.
Теперь попробуем описать систему робота, которого можно включить, есть имя и есть возможность определения уровня. Как 
бы вы стали это делать? Начнем с самого "топорного" кода и будем постепенно улучшать.

Итак, описываем класс `Robot1`, в котором будет несколько полей, в частности `имя` и `уровень`. Далее будет конструктор,
определяющий имя и уровень. Далее несколько методов, позволяющих включить и работать с этим роботом. `0:54:10`. 

Методы: `startBIOS()`, `startOS()`, `sayHI()`, `stopBIOS()`, `stopOS()`, `sayBye()`, `work()`. 

`work()` - отдельный метод, позволяющий работать. И кроме этого надо продумать логику выключения. 

И далее, после описания можно перейти к клиентскому коду. В котором определяем отдельный экземпляр робота `robot1`.

      public class Program {
         public static void main(String[] args) {
         // #region Robot1 demo
   
         Robot1 robot1 = new Robot1("name_1", 1);

Далее если требуется посмотреть информацию о нем:

      System.out.printf("%s %d\n", robot1.name, robot1.level);

Дальше запуск ОС робота с приветствием: `startBIOS()`, `startOS()`, `sayHI()`.

Потом он может выполнить каких-то 3 задачи: `work()` 3 раза.

Если вспомнить, что нужно переходить на уровень абстракции. Т.е. мы не делаем конкретную задачу, напр.: сложить 2 числа,
или перемножить 2 числа, или решить квадратное уравнение. Говорим что нужно выполнить какую-то задачу. Потом если 
понадобиться, можно будет подсунуть отдельное поведение какого-то действия.

Подумаем с точки зрения инкапсуляции и того определения, которое теперь известно. Насколько хорошее, или плохое вот 
такое описание нашего робота? Есть ли здесь какие-то проблемы? Проблем на самом деле уйма:
##### Проблема №1.
Сталкиваемся с тем, что пользователь, так сказать в силу своей безграмотности, может начать тыкать на все подряд
кнопки. Т.е., когда конечному пользователю какой-то системы предоставляешь целый набор кнопочек и тумблеров - в этом
случае гарантировано будет что-то идти не так. Т.е., если у нас задано четкое поведение: сначала загрузка BIOS, потом 
опер-ю систему, потом сказать приветствие. Пользователь, то ли по своему незнанию, либо специально поменять порядок 
запуска робота. Он может сделать загрузку ОС несколько раз, загрузить BIOS, остановит BIOS, скажем "Привет!", скажем 
"Пока!", а потом на выключенном ПК попробуем решить задачу.

       robot1.startOS();
       robot1.startOS();
       robot1.startOS();
       robot1.startOS();
       robot1.startBIOS();
       robot1.startOS();
       robot1.sayHI();
       robot1.sayBye();       
       robot1.work();

И эта система поломается от такого. Нужно как-то ограничить такое поведение. Как? 

##### Проблема №2.
Спокойно взять нашего робота и сказать: пусть он будет 100500-го уровня:

       robot1.level = 100500;

Т.е. наш робот стал 100500-го уровня `0:56:25`. Хорошо это, или плохо? 

> Если это  нельзя менять - значит это нельзя менять. Значит надо это каким-то образом запретить менять пользователю.

Вообще, при проектировании любой системы надо помнить что пользователю нельзя давать свободы. Все что нужно сделать - 
четкие рамки: вот кнопка, её нужно нажать и больше пользователь не должен ничего делать. Пользователь не может поменять 
цвет этой кнопки, если это не предусмотрено функционалом. Он не должен менять размер кнопки. Вот нажми кнопку и всё! 
Нужно помнить об этом всегда.

Попробуем описать новую версию нашего робота. Возьмем наши поля `level` и `name` и опишем для них отдельные методы 
только для чтения, или `getter"ы` на чтение.

    public class Robot2 {
       public int getLevel() {
           return this.level;
       }
   
       public String getName() {
           return this.name;
       } }

Раньше был набор методов для запуска/остановки: BIOS, ОС, приветствие/прощание. Это неправильно. Добавим две кнопки для 
включения/выключения системы `powerOn()` и `powerOff`:

    public class Robot2 {
       /** Кнопка включения */
       public void powerOn() {
           this.startBIOS();
           this.startOS();
           this.sayHI();
       }
   
       /** Кнопка выключения */
       public void powerOff() {
           this.sayBye();
           this.stopOS();
           this.stopBIOS();
       } }

Кнопка `powerOn()` объединяет кнопки запуска в правильной последовательности. Кнопка `powerOff()` объединяет кнопки 
выключения системы. Кнопка `work()` остается бесхозной.

Модификатором доступа `private` скрываем от пользователя кнопки. Также скрываем наши поля `level` и `name`.

    public class Robot2 {
      private int level;
      private String name;

    public class Program {
      public static void main(String[] args) {
        // #region Robo2 demo

        Robot2 robot2 = new Robot2("name_2", 1);

        System.out.printf("%s %d\n", robot2.getName(), robot2.getLevel());
        robot2.powerOn();
        robot2.work();
        robot2.work();
        robot2.work();
        robot2.powerOff();
        // #end region

    } }

С точки зрения клиентского кода создали робота `robot2`. Если потребуется посмотреть имя и уровень робота 2. Далее есть 
кнопка включения, 3 кнопки работы, имитируя работу 3-х задач, кнопка выключения системы.

Вопрос: стала ли наша система лучше? Да, немного стала лучше:
1. стало меньше кнопок;
2. теперь нельзя просто так взять и изменить уровень.

Стало вместо семи кнопок три кнопки. Стало ли от этого лучше? Есть ли вероятность того, что пользователь адекватный и 
не будет 10 раз тыкать кнопку `powerOn()`, или на выключенной системе попробует запустить какую-нибудь задачу? 

Если удалить строку `robot2.powerOn()` то следующие строки `robot2.work()` будут выполняться - инкапсуляция "такая 
себе". Т.е. с одной стороны мы объединили логику и данные, скрыли какие-то детали реализации, но в то же время система 
вообще не функционирует. Точнее она функционирует как-то, но не так как надо. Как можно её ещё улучшить?

    import java.util.ArrayList;

    public class Robot3 {
       
       enum State {
           On, Off
       }

       private static int defaultIndex;
       private static ArrayList<String> names;


       static {
           defaultIndex = 1;
           names = new ArrayList<String>();
       }
    
       private State state;

    }

Описываем класс `Robot3`, внутри добавим пару статических полей `defaultIndex` и `ArrayList<String> names`. Для чего 
нужны эти поля? Дело в том, что в рамках одной системы, как правило, не допускается использование нескольких персонажей 
с одинаковым именем. Сергей таким образом пытается высвободить такой функционал и сделать таким образом, чтобы нельзя
было создать два робота с одинаковым именем. Для этого понадобиться индекс по умолчанию - для нумерации и коллекция 
имен. В статическом инициализаторе `static {}` задан начальный индекс `1` и коллекцию имен инициализируем как пустую 
коллекцию. 

Далее по прежнему остаются поля уровня и имени, но добавляется новое поле состояния `state`. Состояние описывает два 
возможных состояния. (тавтология) Робот, либо включен, либо выключен.

Далее есть прежний конструктор:

    public class Robot3 {
       public Robot3(String name, int level) {
          if ((name.isEmpty()
             || Character.isDigit(name.charAt(0)))
             || Robot3.names.indexOf(name) == -1)
          {
             this.name = String.format("DefaultName_%d", defaultIndex++);
          } else {
             this.name = name;
          }
        
        Robot3.names.add(this.name);
        this.level = level;
        this.state = State.Off;
    } }

Но, нужно обратить внимание. Если пользователь задает имя робота пустым `name.isEmpty()`, или первый символ будет 
цифрой `Character.isDigit(name.charAt(0)`, или такое имя было задано ранее `Robot3.names.indexOf(name) == -1`, то в 
этом случае придумаем дефолтное имя `String.format("DefaultName_%d", defaultIndex++)` с дефолтным индексом. Далее 
описали и добавляем полученное имя в коллекцию `Robot3.names.add(this.name)`. Если ни одно условие не выполнилось, то 
будем использовать имя, данное пользователем `this.name = name`. Далее инициализируем начальный уровень и состояние, 
выключенное. 

Правильное это поведение? Технически - да. Можно ли добавить ещё что-то? Да, можно, напр., нам нужен конструктор, 
имеющий 1 аргумент - имя.

    public Robot3(String name) {
        if ((name.isEmpty()
                || Character.isDigit(name.charAt(0)))
                || Robot3.names.indexOf(name) == -1) {
            this.name = String.format("DefaultName_%d", defaultIndex++);
        } else {
            this.name = name;
        }

        Robot3.names.add(this.name);
        this.level = 1;
        this.state = State.Off;
    }

В этом случае всё остается таким же как и в предыдущем конструкторе, только `level = 1`. 

Также можно описать конструктор без параметров, где будет присваиваться дефолтное имя, уровень 1 и выключенное 
состояние.

    public Robot3() {
        this.name = String.format("DefaultName_%d", defaultIndex++);
        
        Robot3.names.add(this.name);
        this.level = 1;
        this.state = State.Off;
    }

Теперь, посмотрев на эти 3 возможных конструктора, что нам не нравиться в этом коде? Код нехороший. Ответ: нарушение 
принципа `don't repeat youself`. 

    // #region правильные конструкторы ...
    public Robot3(String name) {
        this(name, 1);
    }

    public Robot3() {
        this("");
    }
    // #endregion

1. Конструктор с одним параметром вызывает конструктор с 2-мя аргументами;
2. Конструктор без параметров вызывает конструктор с одним параметром, передавая пустую строку `this("")`.

Далее того чтобы не было возможности явного указания уровня робота технически можно скрыть конструктор с 2-мя 
аргументами, поменяв модификатор доступа на `private`. Тогда для пользователя будет доступно создание робота, задавая 
только имя, или без каких-либо параметров. Все остальное система сделает сама.

Далее пункт - описание системы включения/выключения робота.

    // Методы вкл/выкл подсистем
    public void power() {
        if (this.state == State.Off) {
            this.powerOn();
            this.state = State.On;
        } else {
            this.powerOff();
            this.state = State.Off;
        }
        System.out.println();
    }

Для пользователя создается только одна кнопка включения. Если система выключена - надо вызвать логику включения и 
поменять состояние робота на включенный. Если система включена - надо систему выключить и установить нужное состояние.
Все. Остальная логика остается неизменной. Если потребуется какие-то задачи решать:

    /** Работа */
    public void work() {
        if (this.state == State.On) {
            System.out.println("Working...");
        }
    }

Если состояние включено - решать задачу.

> В коде есть ошибка. `Robot3.names.indexOf(name) == -1` - неверно. Проверка осуществляется на индекс равный -1. Это 
> говорит о том что условие проверяется "если такого имени нет" - это неправильно. Сергей говорит: "если не равен -1", 
> т.е. получается в `names.indexOf(name)` элемент нашелся, значение будет не -1, значит такое имя в данной коллекции 
> `names` содержится, значит надо придумывать имя по умолчанию.

        Robot3 robot3 = new Robot3("name_3");
        System.out.println("--------------------");
        System.out.println(robot3);
        robot3.power();
        robot3.work();
        robot3.power();
        robot3.work();

        robot3.power();
        // #end region

После вывода имени и уровня робота:
1. после нажатия `power()` - включение системы (Start BIOS..., Start OS..., Hello, World!...);
2. после нажатия `work()` - выполнение задач (Working...);
3. после нажатия `power()` - система выключается (Bye..., Stop OS..., Stop BIOS...)
4. пытаемся нажать `work()` - ничего не срабатывает, т.к. на выключенной системе нельзя работать;
5. снова нажимаем `power()` - снова система включается и готова к работе (Start BIOS..., Start OS..., Hello, World!...).

`1:06:47`

Итак, было видно, что такое инкапсуляция. В некоторых случаях, начинающие думают о том, что есть какая-то система, пусть
будет в простом приближении - класс. Поменяли модификатор доступа с `public` на `private` и вроде инкапсуляцию 
выполнили - ничего подобного. 

> Поменять модификатор доступа = поменять модификатор доступа, ничего более.

Когда начинаешь думать: как система будет функционировать после того как внесли изменения - это и есть та самая 
"инкапсуляция". Объединение данных, логики их обработки, сокрытие деталей реализации. Конечному пользователю абсолютно 
все равно как у вас инициализируется уровень. Он знает что надо нажать кнопку и включится. Как будет производиться 
включение ему все равно, т.е. сокрытие деталей реализации. Это и есть 1-й принцип ООП - инкапсуляция.


### Второй принцип ООП. Наследование. 
_**Наследование**_ - это свойство системы, позволяющее описать новый класс на основе уже существующего, с частично или 
полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется базовым или родительским. Новый класс - потомком, наследником
или производным классом.

В чем посыл? Допустим, вы описали какую-то систему, которая хорошо работает, но внезапно понадобилось добавить ну совсем
малый штрих чтобы было ещё лучше, но в то же время другое.

Пример. Есть `Point2D`, внезапно понадобилось работать с точками 3-хмерного пространства. Насколько это сложно? Берем 
точку 2-хмерного пространства, добавляем одну координату, получается точка 3-хмерного пространства. При этом, если 
нормально описана логика то можно спокойно можно оставить методы вычисления расстояния от начала координат. Возможно 
правильно описана логика нахождения расстояния между двумя точками. Возможно для хранения `x,y,z` использовался массив 
или коллекцию. `1:08:37` Если вспомнить, то в самом 1-м модуле об этом рассказывалось. Теперь попробуем принцип 
наследования: как система будет проектироваться без него и с ним.

`1:08:49`

Допустим захотелось описать некую игру с персонажами: маг и священник. Будет 2 класса `Magician` и `Priest`. Далее в 
рамках этих персонажей будет функционал: конструктор, ещё конструктор по умолчанию, некий механизм атаки, метод 
получения информации, метод лечения, метод получения урона. Пакет `Ex007`.

> Важный момент! Теперь, ровно с этой лекции нам должно быть все равно каким образом реализован тот, или иной метод. 
> Кто-то может сидеть и всматриваться в каждую строку кода: как же там написано и как же это работает? Нужно переходить 
> на новый уровень абстракции. Есть метод атаки - ок! Всё, метод атаки. Как он работает? Что он делает - неважно! То, 
> как будет работать атака, будет написано, либо в функциональных требованиях к системе, либо в самом сложном случае 
> когда нам дадут ТЗ совсем четко-четко описанное. Но Сергею в это не верится. В большинстве случаев - это 
> функциональные требования. ТЗ: т.е. мы хотим чтобы персонаж как-то атаковал и как это будет описано. Наша задача на 
> уровне проектирования заложить возможность атаки.

Здесь важно что для каждого из этих персонажей есть свои какие-то тонкости. В частности, если жрецы будут использовать 
какой-то `elixir` (эликсир) для того чтобы произносить свои заклинания, то маги должны использовать условную `mana` 
(ману) для того чтобы произносить уже свои заклинания. Сергей специально сделал такое различие.

На след этапе, говорим что есть какие-то состояния для магов: имя, запас здоровья `hp`, макс запас здоровья `maxHp` и 
т.д. То же самое справедливо и для жрецов. Только у жрецов отличие от магов - эликсир. 

Дальше в рамках проектирования игры, предполагаю что может понадобиться хранение индексов героев `number` и быть может 
метода `random`. Т.е. в случае атаки, герой будет наносить не определенный уровень урона, а случайное значение - детали
реализации, к которым на первом этапе можно не придираться. Передаешь в метод получения урона какую-то величину и метод 
как-то работает.

Система описана, +- одинаковая. Со стороны клиентского кода можно создать 3-х героев:

    public class Program {
      public static void main(String[] args) {
          Magican hero1 = new Magican();
          System.out.println(hero1.getInfo());

          Priest hero2 = new Priest();
          System.out.println(hero2.getInfo());

          Priest hero3 = new Priest();
          System.out.println(hero3.getInfo());
      } }

Получатся 1 маг и 2 жреца. Есть описание жреца и мага. Что сейчас не нравится в описании? Что нравится в описании?

`1:12:51`

Начнем разбираться что плохого в коде? Здесь основной посыл - нарушение принципа `don't repeat yourself`. 
Спроектировали систему. Вроде все хорошо. Дальше начали проектировать другую систему. Под системой понимается отдельный 
вид героя. Они же одинаковые. С точки зрения кода, виды героев отличаются только маной/эликсиром. Причем у них те же 
типы, все то же самое, а отличаются только этим пунктом. 

Насколько было правильно делать копию класса? А если представить что будет не 2 класса персонажей, а 20-ть с одинаковым 
кодом? Это плохо. Как в этом случае поступить? Принцип `наследование`. 

Описываем какие-то общие состояния и поведения и дальше при необходимости дополняем новую систему/класс, используя 
частично, или полностью описанный ранее функционал.

Пакет `Ex008` с наследованием. В первую очередь описываем всю логику, которая справедлива для всех персонажей:
1. вести их подсчет `number`;
2. для любого может потребоваться генератор псевдослучайных чисел `r`;
3. каждый герой имеет имя `name` и запас здоровья `hp`;
4. есть инициализатор статических полей `static {}`;
5. конструктор, отвечающий за инициализацию `BaseHero(name, hp)`;
6. есть, если нужно конструктор по умолчанию `BaseHero()`;
7. метод получения информации `getInfo()`. Можно узнать: имя, уровень здоровья, тип; неизвестно какая мана, ловкость, 
8. или чот-то ещё;
8. метод лечения `healed()`. Он справедлив для любого персонажа;
9. метод нанесения атаки `getDamage()`

> Теперь описываем класс мага `Magician` и говорим что он должен быть `extends` то что в базовом классе `BaseHero`. 
Дословно, класс `Magician` будет являться наследником класса `BaseHero`. По другому можно сказать `Magician` является 
наследником класса `BaseHero`. `BaseHero` является родительским, а `Magician` дочерним. 

За счет наследования, теперь можно использовать всё то, что было описано в базовом классе. Если раньше можно было 
обращаться к полям текущего класса через `this`, напр., `this.mana`, но помимо этого внезапно появляется возможность 
обратиться, напр., к `this.name`. Поле `name` было описано в контексте базового класса `BaseHero`. 

До текущего момента были модификаторы доступа: `public`, `private`. Появился 3-й модификатор доступа `protected`. Что 
такое `protected`?

> `protected` означает дословно, что помеченное таким модификатором доступа будет доступно в рамках текущего класса и в 
> рамках всех классов наследников.

Соответственно, т.к. `Magician` является наследником класса `BaseHero`, то всё что помечено модификаторами доступа 
`protected` и `public` в базовом классе будет доступно и в классе-наследнике. Но есть одно, но! Если раньше, обращаясь 
к полям текущего класса использовали `this`, то для более легкого ориентирования в коде при обращении к полям базового 
класса лучше использовать `super`

    super.name = "something";

Это дословно говорит что нужно идти в базовый класс и там что-то поковырять, посмотреть. Когда будешь путешествовать 
через кнопку `F12`, то можно действительно увидеть это в базовом классе. Если в дочернем классе будет `this` - это не 
будет ошибкой, но будет сложнее ориентироваться в коде, напр., при код ревью.

Как раньше когда переиспользовали конструктор базового класса, напр., `toString()`, аналогично можно сделать и с нашим 
базовым классом `BaseHero`. 

    /** Конструктор мага по умолчанию */
    public Magician() {
        super(String.format("Hero_Magican #%d", ++Magician.number),
                Magician.r.nextInt(100, 200);
        this.maxMana = Magician.r.nextInt(50, 150);
        this.mana = maxMana;
    }

После того как вызван конструктор базового класса можно сделать инициализацию: `maxMana`, `mana`, в нашем случае 
запасы маны. Далее для магов определена логика атаки. Далее метод получения информации.

    public String getInfo() {
        return String.format("%s Mana: %d", super.getInfo(), this.mana);
    }

В методе аргумент `super.getInfo()` вернет значение, которое подсчитывается в `BaseHero`.

На след этапе описываем персонажа жреца `Priest`, который также будет наследником класса `BaseHero`. Для него можно 
определить своим какие-то состояния: `elixir`, `maxElixir`. Далее описываешь свою логику атаки и получения информации. 

Сточки зрения клиентского кода:

        Magician hero1 = new Magician();     // создали мага
        System.out.println(hero1.getInfo()); // посмотрели инфу о маге

        Priest hero2 = new Priest();         // создали жреца
        System.out.println(hero2.getInfo()); // посмотрели инфу о жреце

        Priest hero3 = new Priest();
        System.out.println(hero3.getInfo());

        hero3.GetDamage(hero2.Attack());     // hero2 атакует, hero3 получает урон
        System.out.println(hero3.getInfo());
        System.out.println(hero2.getInfo());
        // hero3.GetDamage(hero3.Attack());

Насколько это `hero3.GetDamage(hero2.Attack())` корректно с точки зрения логики? Когда фактически 3-й персонаж говорит 
2-му: а давай ты меня сейчас ударишь. А 2-й значит подходит и бьет его палкой. Правильно ли это? Ну наверное так себе.

Здесь ещё такой интересный момент получается что персонаж может себя сам дубиной огреть. 

Насколько хорошо здесь продумали инкапсуляцию для описания такой системы? Сейчас главный момент - это понимание того как
работает сама идея наследования. Сначала описываем какой-то общий базовый функционал, который гарантировано будет для 
всех и оно будет одинаковым. `1:20:43`
После этого создаем конкретных наследников для каких-то деталей. 

Как можно создать команду из этих двух персонажей: магов и жрецов? 


    public class Teams {
      public static void main(String[] args) {
         int teamCount = 10;                                // количество персонажей
         Random rand = new Random();
         int magicianCount = rand.nextInt(0, teamCount);    // генерация кол-ва магов
         int priestCount = teamCount - magicianCount;       // остальные - жрецы

         System.out.printf("magicalCount: %d priestCount: %d \n", magicianCount);

         Priest[] priests = new Priest[priestCount];           // создание отдельного массива для хранения жрецов
         Magician[] magicians = new Magician[magicianCount];   // создание отдельного массива для хранения магов

         /** Наполнение массива жрецами */
         for (int i = 0; i < priestCount; i++) {
            priests[i] = new Priest();
            System.out.println(priests[i].getInfo());
         }
        // Name: HERO_PRIEST_D #1 Hp: 143 Type: Priest Elixir: 56
        System.out.println();

        /** Наполнение массива магами */
        for (int i = 0; i < magicianCount; i++) {
            magicians[i] = new Magician();
            System.out.println(magicians[i].getInfo());
        }

      }
    }

Итак, технически работает, но есть проблема. Проблема связана с тем что если в рамках игры будет не 2-а, а 20-ть 
персонажей - то ждут большие проблемы. Как от этой проблемы можно избавиться? Теперь перейдем к след принципу, который 
является сложным принципом.

### Принцип ООП. Полиморфизм. 1:22:17
Вообще определения полиморфизма достаточно специфичное и наизусть его никто и никогда не станет учить. В то же время его
можно коротко сформулировать. 

_**Полиморфизм**_ - это свойство системы, использовать объекты с одинаковым интерфейсовм без информации о типе и 
внутренней структуре объекта.

_**Полиморфизм**_ - это способность использовать объект вне зависимости от его реализации, благодаря, полиморфной 
переменной - это переменная, которая может принимать значения разных типов.

Под полиморфизмом мы понимаем возможность положить в переменную базового класса любого из его производных. Это значит, 
что мы проектировали систему в рамках которого была точка 2-хмерного пространства. От неё делали наследование дял точки 
3-хмерного пространства. На след этапе берем точку 2-хмерного пространства и кладем в неё экземпляр 3-хмерного 
пространства. И всё по-прежнему должно всё работать. По-прежнему в рамках базовой системы должны работать методы 
вычисления расстояний, методы печати, ровно так как это должно быть. 

Посмотрим что это дает? Что этот принцип дает в рамках проектирования псевдоигры? `1:23:08`

В рамках: `BaseHero`, `Magician`, `Priest` - почти ничего не поменялось, но дополнился функционал в клиентском коде.
Базовое поведение - напр., создать экземпляр мага класса `Magician`. Когда речь идет о полиморфизме, то можно создать 
переменную базового класса и положить в неё экземпляр производного класса.

    BaseHero hero3 = new Magician();
    System.out.println(hero3.getInfo());
    BaseHero hero4 = new Priest();
    System.out.println(hero4.getInfo());

Если данную систему запустить, то всё должно работать как будто ничего специфичного не произошло. 

> В этот момент у тех кто не знаком с ООП случается взрыв мозга.

Как это возможно? Если базовый класс ничего не знает об эликсирах, мане, но при этом почему-то это работает. Это 
полиморфизм, детка.

На след этапе, зная такое поведение, можно немного перестроить систему, в частности систему атак. Если метод атаки был 
в контексте конкретного класса, теперь логика будет вынесена в базовый класс `BaseHero`:

    public void Attack(BaseHero target) {
        int damage = BaseHero.r.nextInt(10, 20);
        target.GetDamage(damage);
    }

В качестве аргумента этому методу будет передаваться переменная базового типа, дальше генерация случайного числа урона и
дальше цели `target` в качестве аргумента метода `GetDamage()` значение этого урона `damage`. Тот экземпляр, на котором 
был вызван метод атаки будет сгенерирован и передан нашему бедолаге.

        // #region ex2 Attack
        System.out.println(hero3.getInfo());
        System.out.println(hero4.getInfo());

        hero3.Attack(hero4);
        System.out.println(hero4.getInfo());

        hero3.Attack(hero4);
        System.out.println(hero4.getInfo());
        // #endregion

В данном случае маг и жрец обменяются ударами.

Как можно увидеть, полиморфизм упростил взаимодйствие наших персонажей. Если бы не было полиморфизма, то нам бы пришлось
отдельно описывать метод атаки в случае, если целью является маг, потом точно такой же метод (перезрузку метода), 
который в качестве цели будет выступать жрец. Если дальше пришлось описать 20 типов игровых персонажей, то пришлось бы 
добавлять 20 различных методов, 20 перегрузок. Причем эти 20 методов пришлось бы добавлять (инкапсулировать) в каждую 
сущность, потому-что в одном случае может выступать маг и может атаковать 20 других классов. Также надо описать аткаку 
для жреца на 19 других классов. Таким образом не получилось бы вынести это в общую логику.

Как создать команду персонажей и использовать полиморфизм? Как и ранее, создаем 10 персонажей. Далее создать коллекцию 
базового класса `BaseHero`. `1:28:48`.

        // #region Teams
        int teamCount = 10;
        Random rand = new Random();
        int magicianCount = 0;
        int priestCount = 0;

        List<BaseHero> teams = new ArrayList<>();
        for (int i = 0; i < teamCount; i++) {
            if (rand.nextInt(2) == 0) {
                teams.add(new Priest());
                priestCount++;
            } else {
                teams.add(new Magician());
                magicianCount++;
            }
            System.out.println(teams.get(i).getInfo());
        }
        System.out.println();
        System.out.printf("magicalCount: %d, priestCount:  %d \n\n", magicianCount, priestCount);

Будет создана команда из десяти персонажей. Отдельные переменные для подсчета магов и жрецов: `magicianCount`, 
`priestCount`. Новая коллекция `ArrayList` базового класса `BaseHero`: 

    List<BaseHero> teams = new ArrayList<>();

Далее логика в цикле: если 0 - создать жреца, если 1 - мага.

Т.е. технически, принцип полиморфизма абсолютно хорошо себя чувствует даже при условии проектирования нашей команды. 

### Итоги
Это базовое введение в принципы ООП (подхода). На данный момент надо:
1. понять что такое класс, что такое экземпляр класса?;
2. четко запомнить что такое ООП?;
3. почему инкапсуляция и изменение модификатора доступа - это не одно и тоже;
4. потренироваться в контексте описания отдельных иерархий систем когда есть наследование, какое-то базовое, от него 
наследуется что-то. Вот выстраивание иерархий;
5. далее есть полиморфизм. Можно подумать: где уже сталкивались с полиморфизмом?;
6. далее можно взять исходники и  попробовать спроектировать под себя. Попробовать продумать с точкой 3D: описать 
сущность, добавить какое-то поведение, простроить иерархию типов с точностью до 3-хмерного, 4-хмерного, или возможно 
n-мерного пространства;
7. на семинарах запросить код ревью: как можно улучшить код?;
8. по исходникам попробовать добавить других персонажей псевдоигры. Как они будут взаимодействовать? В исходниках есть 
метод атаки, также есть метод лечения. Добавить персонаж "лекарь" чтобы он мог лечить других персонажей.

Если огорчился, то помнить принцип: "если сейчас ты знаешь то, что не знал 2 часа тому назад - это хорошо!". Теперь 
осталось это на практике.

##### Проблема №3. Не раскрыта. 

### Snippets

1. ctor  - IDEA, don't work
2. get; set;
3. docs - IDEA, don't work
