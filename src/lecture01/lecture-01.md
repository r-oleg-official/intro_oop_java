## Lecture 1. Введение в ООП. Свои типы и концепты.

Способ управления сложными системами: "Разделяй и властвуй".

Это значит, что программную систему нужно разбить на подсистемы так, чтобы работу каждой из них можно было
рассматривать и совершенствовать независимо от других.

Теперь снова надо будет рисовать блок-схемы только более сложные.

Сначала писали какой-то код и он как-то работал. Далее появилась тема методов. Теперь нужно было продумать код так,
чтобы он не был завязан на определенных данных. Напр., код для ввода с клавиатуры, или считывание с файла. Т.е. когда
была задача: сложить два числа, то это была задача не про сложение каких-то двух чисел, а речь про любые числа.

Получается были этапы:
1. писали код стихийно;
2. перешли к процедурному подходу: писали какие-то методы и функции;
3. объединение данных и методов над которыми работали.

Примерно так происходит эволюция перехода в **`Объектно-Ориентированное Программирование`** (`ООП`). Идея ООП родилась
давно, но до сих пор она актуальна.

#### Тезисы ООП:
1. Правильное пан-реализация только после абстракций;
2. Абстракция - что делает?
3. Поведение - как делает?
4. Спецификация - набор правил, описывающих API?

##### 1-й тезис.
Прежде чем начать писать код - надо сесть и подумать: что будешь писать?. Но! Подумать не по принципу: как
это будет работать? А что это будет вообще такое? Если разрабатываешь какую-то систему, напр., сложение двух чисел,
определяем: какие сущности будут в приложении, в системе? Если речь про складывание чисел, то сущность будет - число.
Это сильно просто. Но если будем работать с точками 2-хмерного пространства, тогда определяем отдельную сущность,
которая описывает структуру данных - точку. Как следствие, для точки справедливо для 2-хмерного пространства:
координата `х` и `у`. Всё ли это?

На след-м этапе надо подумать: а как печатать эту точку? Хочешь ли показать только координаты точки, или какой-то
красивый вывод? Напр., (х, у), (х; у), или {х:у}, или как-то по другому.

Какие операции справедливы для точки? Напр., для проектирования, для описания векторов.

> Когда проектируешь надо четко понимать: какую задачу решаешь?

Если явно не описано в функциональных требованиях к продукту, или в ТЗ что дальше будем работать с векторами. В таком
случае такое поведение закладывать не нужно. Если говорят, что работать с точками, описан перечень действий, который
нужно производить с этими точками, значит их и нужно описывать.

В данном случае, попробуем описать систему, которая позволяет объявить для начала точку и дальше, напр., вычислить
расстояние между двумя точками и красиво распечатать эту самую точку. Как это сделать?

##### 2-й тезис. Абстракция.
Когда описываешь какую-то систему, выделяя в ней отдельные сущности, нужно обдумывать ни как делает эта сущность, или
каким образом будет реализовывать тот или иной функционал? А для начала надо описать на уровне абстракции. Есть
какая-то сущность, может что-то делать. Как это делать - отвечает отдельный конкретный представитель. В частности, если
рассмотреть большое семейство котиков. Для любого котика справедливо у него есть: лапки, кличка, высота полки, окрас
шерсти и т.д. Напр., возьмем кота: шотландский вислоухий, серого цвета, у него голубые глаза.

Вот это разделение и есть общие абстракции, когда речь про: окрас шерсти, высота полки, кличка. И в то же время
конкретное состояние, в данном случае: серый окрас шерсти, голубые глаза и т.д.

Дальше когда речь о проектировании, нужно четко понимать какими состояниями и поведениями обладает та, или иная
сущность. Если говорить о котике. Под состояниями можно понимать: высота полки, окрас шерсти, кличка, порода. А под
поведением можно понимать котик может: спать, кушать, бегать, прыгать, баловаться и т.д. То же самое справедливо для
любой сущности, системы, которая будет описываться. Для начала концентрируемся на объявлении на конкретных таких
сущностей. Далее ждут проекты целых сервисов и надо будет переходить на след.-й уровень абстракции когда нужно
продумать о том как же, или что же, или каким образом будет делать тот, или иной сервис.

Допустим, надо написать соцсеть `VK`. Нужно четко понимать, что в ней должен быть функционал воспроизведение
песен, видео, отправка сообщений, наличие стены. И дальше, исходя из этого, начинаешь разрабатывать.

Для того чтобы описать возможность прослушивания музыки - нужна сущность "песенка". У песенки есть длительность,
битрейт, название, исполнитель, год исполнения.

> У песенки есть деятельность 0:08:25.

Таким образом, от самого большого будешь спускаться все, все меньшему, меньшему, к каким-то системным единицам.

> Абстракция отвечает на вопрос: что именно делает та, или иная сущность? А конкретным поведением обладает конкретный
> экземпляр, или представитель вот этой самой сущности.

##### 4-й тезис. Спецификация.
Спецификация - набор правил, описывающих API. Но что же такое `API`? 

`API` - как ранее говорили, набор методов, их конкретное действие, наименование этих методов, или описание этих методов 
должны быть понятны конечному потребителю нашего сервиса, использование наших сущностей, библиотеки и т.д.

Т.е. здесь сначала нужно исходить из того что у нас будет соцсеть `VK`, у неё будет:
1. отправить сообщение;
2. прослушать песню;
3. просмотреть видео и все.

А дальше начинается идея, что вот в этот функционал, в эту спецификацию продумываете какие-то сервисы в более широком 
представлении. 

После того как определили, как будут называться, как будут описываться сервисы, будете подгонять отдельные сущности, 
напр., ту же сущность `трек`, или если говорить напр., о проектировании достаточно больших систем, даже казалось бы 
самая простая идея песни/трека - она может содержать в себе большое кол-во артистов. А артист - отдельная сущность. 
Потому-что у артиста есть:
1. фамилия;
2. имя;
3. может быть наименование альбома;
4. и т.д.

Т.е. разбирая большую казалось бы систему на такое маленькое количество на абсолютно тривиальных таких сущностей.

Пока может показаться эта информация непонятной, или может быть непонятно как применять эту информацию? Но надо 
набраться терпения, к концу курса все встанет на свои места. 

> Когда речь идет об объектно ориентированном подходе - ваша задача: мыслить теперь уже не просто какими-то переменными,
> какими-то циклами, или какими-то методами. Задача мыслить классами и конкретными представителями этих классов, т.е 
> экземплярами классов.

#### Класс

**Класс** - это `чертеж` (описание) сущности предметной области, позволяющий выделить некоторые общие характеристики, 
состояние и поведение, зависящее от состояния.

Вспомнить: что относится к классу, что к поведению, что к состоянию?

Далее большой "пласт" - `экземпляры класса`.

#### Экземпляр класса
**Экземпляр класса** - отдельный представитель класса, имеющий КОНКРЕТНОЕ состояние и поведение, которое полностью 
определяется описанием класса.

Напр., если есть класс `котики`, то конкретный "Барсик" - это и есть тот самый конкретный экземпляр класса.

Очень часто экземпляр класса отождествляют с понятием объекта. 

> Для "джуна" - это довольно нормальное поведение. Но если идешь на собеседование выше +- средний миддл, то все-таки 
> надо немножко разделять. К концу курса станет известно отличие.  0:11:30

После того как узнали что есть классы, экземпляры классов, теперь нужно понимать чем наполнять эти самые классы.

**Экземпляр класса**:
1. состояние:
   - поля
   - константы
   - события
2. поведение:
   - конструкторы
   - методы

> В поведении класса в общем случае больше 2-х пунктов, но пока оставим как есть.

На данном этапе из состояний достаточно `поля`, а из поведений: `конструкторы` и `методы`. Пока этого хватит.

**ООП** - Объектно-Ориентированное Программирование. 0:12:11

Парадигма (стиль, шаблон) разработки ПО, основными понятиями которой являются классы и объекты. Говорят, что разработка 
в стиле ООП ведется с использованием классов объектов, которые обладают состоянием и поведением, зависящим от этого 
состояния.

По другому, объектно-ориентированный подход - это попытка мыслить, или проектировать системы с использованием этих 
самых классов и экземпляров этих самых классов, но ещё говорят "и объектов".

#### Код на примере вычисления координат 2-хмерного пространства.
      public class PointMethodEx001 {
         static double distance(int x1, int y1, int x2, int y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
         }

         public static void main(String[] args) {
           int ax = 0;
           int ay = 0;
           int bx = 0;
           int by = 1;
           System.out.println(distance(ax, ay, bx, by));
      //   Создать точку
      //   Печать точки
         }
      }

Начнем издалека, используя "стихийный подход" в программировании, т.е. определяем точку 2-хмерного пространства. У 
точки есть две координаты. Есть одна точка `a` координата (х и у) и другая точка `b` с координатой (х и у). Далее 
описываем `а(х)`, `а(у)`, присваиваем какие-то значения. Дальше есть `b(х)`, `b(у)`, присваиваем какие-то значения.
Далее описываем метод, напр., `distance()`, который принимает эти 4-е аргумента и считает расстояние между точками.

Можно пойти другим путем. Представить каждую точку массивом/коллекцией или чем-то другим. Технически возможно. Но сути 
дела это особо не меняет. 

Это был "стихийный подход", в котором были описаны 4-е координаты. Дальше есть какой-то метод `distance()`, считающий 
расстояние и дальше результат как-то используется. Это "стихийный подход" (набор переменных)с приправленный процедурным 
(набор методов). 

Технически, можно было сделать чтобы метод возвращал пару чисел, которая представляла собой точку и т.д., но оставим 
как есть.

Так вот, когда идет речь о попытке перехода в контекст объективно-ориентированного подхода, то нужно выделить сущность 
"точка".

Point2D.java:

      public class Point2D {
         int x, y;
      }

PointMethodEx002.java:

      public class PointMethodEx002 {
         static double distance(Point2D a, Point2D b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2)); 
            // ошибка в лекции: 1- b(x)-a(x); 2- a(x)-b(x)
         }
      
          public static void main(String[] args) {
              Point2D a = new Point2D();
              a.x = 0;
              a.y = 2;
              System.out.println(a.toString());
      
              Point2D b = new Point2D();
              b.x = 0;
              b.y = 10;
              System.out.println(b.toString());
              System.out.println(distance(a, b));
          }
      }

Есть класс `Point2D`, для которого определены 2-е точки. Эти самые `x` и `y`, которые раньше назывались переменными, 
теперь они наз., `полями`. 

> Какая-то переменная в контексте класса наз. - полем.

Это ни хорошо, ни плохо, просто это так.

Теперь логику можно описывать след образом. Раньше в метод передавались 4-е аргумента, что-то себя представляющие. 
Теперь есть метод, который принимает 2-е точки. Переходим на след уровень абстракции. Есть какая-то точка `a`, а у 
точки `a` есть какие-то: `x` (a.x), `y` (a.y); с которыми дальше пытаемся манипулировать.

Дальше определяем "представителя", или "экземпляр" класса.

      Point2D a = new Point2D(), 
где, `Point2D` - класс, `a` - экземпляр класса, `a.x = 0` - значения нужных полей, `new Point2D()` - конструктор класса. 

Вычисление происходит с помощью метода `distance(a, b)`, в который передаются 2-е точки.

> Класс - это описание каких-то общих характеристик. 

> `a` и `b` - экземпляры класса. Конструктор создает новый экземпляр данного класса.

> Память. `a` будет размещаться в `STACK`, а всё остальное в куче `HEAP`. Это грубое объяснение.

Пока не вызовешь `конструктор класса`, непонятно где хранить те самые `x` и `y`.

Так что надо запомнить и вспомнить тот материал, в котором рассказывалось на примере работы с кучей и то, как можно 
получить неприятные ситуации.

Итог. Мы описали некую сущность "точка". Можно сказать что в точку `инкапсулировали` значения координат (х и у) точек. 
Но попробуем наполнить созданный класс каким-то доп `поведением` и попробуем что-то описать.

Для `поведения` существуют: конструкторы и методы. 0:16:03.

Допустим, не хочется писать след образом:

      a.x = 0;
      a.y = 2;

Хочется вызвать конструктор и передать 0 и 2 след образом:

      Point2D a = new Point2D(0, 2);

Теперь такое поведение добавить в класс `Poind2D`. Если у нас есть поля `x` и `y`. Надо описать некоторый конструктор, 
можно использовать сниппет `ctor` (в `IDEA` не работает). 

> В `IDEA` пр. кл. мыши -> Generate... Alt+Ins -> Constructor.

Point2D.java:

      public class Point2D {
         int x, y;

         public Point2D(int valueX, int valueY) {
            x = valueX;
            y = valueY;
         }
      }

`public Point2D()` похож на метод, но это не метод, т.к. нет возвращаемого эл-та (int/String...)

Далее, пусть будут некоторые значения, напр., `int valueX`, `int valueY`, описываем это как будто это обычные аргументы.
Далее присваиваем: `x = valueX`, `x = valueY`. 

Теперь появляется возможность в клиентском коде передавать значения `x, y` как аргументы в конструктор. 

> Клиентский код - код, в котором создают сущность, через конструктор, напр., `Point2D a = new Point2D()`.

Задача выполнена. Теперь создавать точку надо так:

      Point2D a = new Point2D(0, 2);

Но конструктор `new Point2D()` теперь недоступен. Почему нельзя использовать? Т.е. пытаешься что-то делать по умолчанию,
то есть поведение по умолчанию. 

> Конструктор у которого нет аргументов, наз., конструктором по умолчанию. Технически можно написать свой конструктор 
> по умолчанию, для того чтобы описать поведение.

Если же начинаешь описывать пользовательский конструктор (как раз то что сделали), то в этом случае всё что было до него
по умолчанию оно как бы испаряется. Поэтому можно описать ещё конструктор, работающий с иной логикой. Для этого 
перейдем в класс `Point2D` и добавим ещё один конструктор, можно через сниппет `ctor`. Пока без параметров.

> В `IDEA`: Generate... -> Constructor, далее в нем сразу нажать кнопку `Select None`.

      public class Point2DEx003 {
         public Point2DEx003() {
         x = 0;
         y = 0;
         }
      }

Т.е. в конструкторе мы переопределяем `x` и `y`, равные нулю. Технически здесь в конструкторе можно объявить какое-то 
свое поведение, т.е. пусть `x = 10`, `y = 28`. Можно? Да, можно. Правильно ли это поведение? Нет, неправильное в данном 
случае.

Хорошо, помимо этого можем сказать: а давайте пусть конструктор принимает 1 аргумент, напр., `value`. В `x` и `y` будем 
ложить `value`. 0:18:54

      public class Point2DEx003 {
          public Point2DEx003(int value) {
              x = value;
              y = value;
          }

Т.е., если потребуется описать точку, которая будет `а(10, 10)`. Можно описать топорно:

      a.x = 10;
      a.y = 10;

или 

      Point2D a = new Point2D(10, 10);

Но теперь можно еще и так:

      Point2D a = new Point2D(10);

Доступно два варианта создания экземпляра класса.

Сейчас, когда пытаешься распечатать на экране точку `a`, то можно увидеть какую-то чепуху:

      System.out.println(a);
      // lecture01.Point2DEx003@5acf9800

Что это значит? Это значит, что по умолчанию у нашего класса `Point2D`, `Point2DEx003` и т.д. есть какое-то свое 
поведение, отвечающее за преобразование этой точки в строку. Значение по умолчанию определяется методом `toString()`.

Т.е. технически когда в `System.out.println()` передана аргументом точка в виде `a`, автоматически вызывается метод 
`a.toString()`.

      System.out.println(a.toString());

Правильно это поведение? Технически нет. Нам это не совсем удобно. Можно описать отдельный метод, который будет 
показывать точку так как нам нужно. Пусть это будет метод `getInfo()`, возвращать будет `String`, пока указать `public`.

> Наперед забегая, `public` - это модификатор доступа.

      System.out.println(a.getInfo());

      public class Point2DEx003 {
          public String getInfo() {
              return String.format("x: %d; y: %d", x, y);
          }
      }

Если, напр., сделать след образом, то `a` нормально, а `b` нет:

      System.out.println(a.getInfo());
      // x: 0; y: 2
      System.out.println(b.toString());
      // lecture01.Point2DEx003@279f2327

> Все что было написано до нас, можно переделать под себя. Это называется "переопределением метода".

Если есть метод `toString()` и он показывает непонятно что, то можно переопределить поведение метода под себя. Для 
этого начинаешь писать `to` и, напр., `IDEA` подскажет `public String toString()   Object`. 0:22:39. 
Важным моментом здесь является `@Override`. В методе `public String toString()`, который с `@Override` заменим 
возвращаемое значение с `super.toString()` на `getInfo()`.

    public class Point2DEx003 {
       @Override
       public String toString() {
           return getInfo();
       }
    }

Теперь если пойти в клиентский код и запустить, то внезапно, передавая аргумент `b` в `System.out.println()` получим 
отображение точки в консоли в нужном виде.

    System.out.println(b);
    // x: 10; y: 10

Если заметить, то метод `getInfo()` по большому счету не нужен - его возвращаемое значение поместить в возврат метода 
`public String toString()` с `@Override`. Но Сергей сделал это для демонстрации идеи использования модификаторов 
доступа. 

#### Модификаторы доступа
1. Если стоит модификатор доступа `public`, то по умолчанию считается что этим методом, или членом класса можно 
пользоваться откуда угодно, т.е. любой может получить к нему доступ. 
2. Если метод пометить как `private`, то он будет доступен только внутри того класса, где его описывать и где его в 
дальнейшем можно будет использовать.

Если у метода `getInfo()` модификатор доступа заменить на `private`, то при вызове:

    System.out.println(a.getInfo());
    // java: getInfo() has private access in    // Error

До этого метода не получится достучаться. При попытке запустить ждет ошибка компиляции 
`java: getInfo() has private access in`. В `IDEA` метод будет подчеркнут красной волнистой чертой, если навести курсор 
мыши на метод, или нажать `Alt + Enter` (Show Context Actions) можно прочесть то же самое и рекомендации по исправлению.
Или в `VS Code` может при наведении на метод появится подсказка и в ней `"...method getInfo()... is not visible"`. 
Теперь метод `gedtInfo()` недоступен для внешних агентов, или клиентов, в нашем случае для клиентского кода.

> Помимо, кроме методов которые описываем сами, в некоторых случаях в контексте ООП, приходится переделывать за кем-то.

Здесь, напр., `toString()` был написан разработчиками Java. Допустим, мы сказали что не подходит и сделали так как 
нужно, добавив `@Override`. Тем самым переопределили поведение метода, которое было сделано кем-то до нас. Это 
справедливо как для стандартных методов, которые использовали, описывали разработчики Java, так и для ваших коллег.
Если написали сегодня какую-то библиотеку, те которые придут после нас, будут использовать такое переопределение 
стандартного функционала через `@Override`. 

Но. В большинстве случаев когда разработчики между собой общаются, они понимают значение слова `переопределение` и в 
некоторых случаях `перегрузка`. И, как правило, они понимают это одно и тоже, или из контекста понятно о чем идет речь.
Сергей говорит, что в рамках лекции он может спокойно не заметить что говорит термин `переопределение` или `перегрузка` 
какого-то метода. Лучше сразу разобраться и запомнить.

> __*Переопределение*__ - это изменение поведения метода, которое было до меня. Было какое-то поведение в рамках 
> старого класса/сущности. Дальше его переопределил под себя в рамках новой сущности. Обязательно `@Override`.

> __*Перегрузка*__ метода. Он, как правило, справедлив для ЯП: Java, C#, Swift, ну и на самом деле для многих ЯП это 
> определение применяется.

Так вот перегрузка говорит о том, что вы описываете в рамках одной сущности методы, отличающиеся сигнатурой.

> __*Сигнатура*__ - с лат. *signatura*, "обозначение".

Когда есть один метод и в нем напр., изменяется кол-во аргументов, или тип данных этих аргументов - это и есть те самые 
перегрузки методов. 0:26:14.

В нашем примере, когда были 2 метода с одним названием `distance`, но один принимал аргументы (`int x1`, `int y1`, 
`int x2`, `int y2`), а другой (`Point2D a`, `Point2D b`).

> Внимание! В некоторых ЯП, в частности в Java, нельзя делать перегрузку по имени аргументов.

Например:

    static double distance(int x1, int y1, int x2, int y2) {}
    static double distance(int a, int b, int c, int d) {}
    // don't work

В примере 4 аргумента с сигнатурами `int` и возвращаемым значением `double`. Даже если менять имена аргументов, все 
равно Java будет ругаться и не пропустит такой финт. Заработает, если уменьшить кол-во аргументов, изменить тип одного 
из аргументов, или тип возвращаемого значения метода:

    static double distance(int a, int b, int c) {}
    или
    static double distance(int a, int b, int c, Double d) {}
    или    
    static int distance(int a, int b, int c, int d) {}
    // work

> Есть такие ЯП где допускается перегрузка по имени аргументов, напр., `Swift`.

Если вернуться к примеру с классу `Point2D`, то были перегрузки только в контексте конструкторов.

    // Конструктор с 2-мя аргументами
    public Point2DEx003(int valueX, int valueY) {
    x = valueX;
    y = valueY;
    }

    // Конструктор без аргументов
    public Point2DEx003() {
        x = 0;
        y = 0;
    }

    // Конструктор с одним аргументом
    public Point2DEx003(int value) {
        x = value;
        y = value;
    }

Таким образом, имея понятия конструктора и методов, понимаете сколько здесь можно всякого творить. Можно описывать 
разные конструкторы, т.е. делать перегрузку этих конструкторов, в том числе можно использовать базовое поведение, 
которое было до нас. Есть методы, которые мы сами описываем и те, бывшие до нас, тоже можно переопределять. В то же 
время все это можно миксовать: взять старый метод, добавить к нему новое поведение. Или сделать перегрузку этих методов 
и т.д. 

Вроде бы все понятно, но Сергей рассказывал про `"don't repeat yourself"` (не повторяйся). Если посмотреть на код 
`Point2D.java`, поведения точки в описании не сильно то отличаются, отличие - разное количество аргументов.

В нашем случае, делаем инициализацию только 2-х аргументов `x` и `y`. А что если у нас будет котик у которого будет 
целый набор аргументов? Получается надо будет описывать 4-е конструктора в которых будет 10 строчек одних и тех же? Это 
неправильно. Для этого есть возможность пере-использования ранее описанных конструкторов. Используем максимально 
"широкий" конструктор, т.е. подразумеваем использование максимальное количество аргументов. `0:29:23`.
Вместо методов `public Point2D` с одним и двумя аргументами можно описать метод с одним аргументом `int value`, вместо 
`super()` написать:

    public Point2D(int value) {
    this.x = value;
    this.y = value;
    }

Это равноценно предыдущему варианту с `x = value`, `y = value`. 

> `this.x` - означает что пытаешься найти поле `x` в рамках текущей сущности/класса.

Но что если будем использовать `this.` с конструктором, описанным ранее:

    public Point2D(int valueX, int valueY) {
        x = valueX;
        y = valueY;
    }

    // Конструктор с this
    public Point2D(int value) {
        this(value, value);
    }

Вызывая конструктор `Point2D` с одним аргументом, на самом деле будет вызываться конструктор с 2-мя аргументами.

Дальше можно описать конструктор без аргументов, т.е. переопределить конструктор по умолчанию, теперь есть возможность 
вызова конструктора с одним аргументом, или с 2-мя:

    public Point2D(int value) {
        this(value, value);
    }

    // Конструктор по умолчанию с одним аргументом
    public Point2D() {
        this(0);
    }

    // Конструктор по умолчанию с одним аргументом
    public Point2D() {
        this(0, 10);
    }

Случай с конструктором по умолчанию с одним аргументом будет каскад вызовов:
1. `Point2D()`, далее передается управление с одним параметром через `this(0)`;
2. `Point2D(int value)`, далее вызывается конструктор с 2-мя аргументами через `this(value, value)`;
3. `Point2D(int valueX, int valueY)`, производим инициализацию, `x = valueX`, `y = valueY`;
4. возвращаемся в `Point2D(int value)`;
5. возвращаемся в `Point2D()`. 

`0:31:24`

Таким образом, начинаем придерживаться принципу `dry`. 

> Принцип `dry` говорит о том, что написали один раз "четкий" код, а дальше будем его использовать ровно так как нам 
> это нужно. Т.е. подставляем конкретные значения, а Java, или другой ЯП пусть сам разбирается как это сделать.

В ЯП C# такое тоже возможно. В других ЯП не факт, что такая возможность есть, поэтому надо быть внимательным.

#### Следующий момент. Защита полей.
Метод `getInfo()` пусть останется, но технически он не нужен. Подумаем над интересным моментом: определили точку 
`new Point2DEx004(0, 2)`, передав конкретные значения (0, 2). Дальше начинаем работать с этой точкой. Но! Внезапно 
приходит какой-нибудь жулик и начинает в нашем коде что-то писать, что писать на самом деле нельзя. Напр., он берет и 
говорит: а давайте мы в точку `а(х = -20)`? Хорошо ли это поведение? Должна ли у нас быть возможность изменения таким 
образом у конкретной точки конкретной координаты? Технически, да, можно сказать: может быть. 

Теперь представим ситуацию, когда описываем игру, в которой создается какой-то персонаж. Персонаж по умолчанию должен 
иметь уровень 1. Но приходит жулик, включает `Artmoney` и говорит: а теперь по умолчанию будет персонаж 100-го уровня.
Правильно ли это поведение? 

Следующий сценарий. Создается игра. На старте игры дается 600 золота, чтобы произвести какую-то закупку. Но внезапно, 
снова запускается какая-то программа/скрипт, который "идет" в наш код и аккуратно подменяет то значение `600` на `6000`.
Таким образом, персонаж 1-го уровня превращается в персонаж 100-го уровня, персонаж 600-та золотых монет превращается в 
персонаж 6000-и золотых монет. Правильно ли это поведение?

Нет, это неправильно! Получается надо придумать функционал, который поможет избавиться от таких "детских болячек".

Если перед полями не стоит никакой модификатор доступа, то считается по умолчанию `public`.

    public class Point2DEx005 {
      private int x, y;    // default public
    }

В текущем состоянии, в клиентском коде не сработает `a.x = 14;`. Но в то же время и прочитать не сможем координаты. 
Правильно ли поведение? Нет, неправильно.

В некоторых случаях может потребоваться прочитать значение конкретной координаты. Т.е., да действительно есть 
возможность использования `a.toString()`, но зачем `toString()`? Потом парсить строку, если я хочу показать:

    System.out.println(a.x);

Сергей говорит, что сейчас нет возможности, полностью закрыт доступ к этому аргументу (полю `x`). Как его (доступ) 
получить? Для этого можно в рамках нашей сущности описать метод и разграничить права доступа. 
1. если получаем целочисленную координату, то можно начать писать в `IDEA` `pu`, а дальше выбрать подсказку `public int 
getX() {...}`;


     public int getX() {
         return x;
     }

Аналогичным образом

     public int getY() {
         return y;
     }

Теперь в рамках клиентского кода у нас есть отдельный метод, возвращающий координату `x` - `getX()` и отдельный метод, 
возвращающий координату `y` - `getY()`. Как понимаете, возможности изменить значения этого поля нет. Но, если вдруг 
потребуется в какой-то момент такая возможность, то идем в исходный класс и дополняем его новым поведением. В нашем 
случае это будет - изменить координату `x`, или `y`, или изменить обе.

> Внимание! Когда делаешь `a = new Point2D()` далее по коду, то фактически создаешь новую точку, размещая в новом 
> участке памяти. И все что было до этого теряется. И это иное поведение и это будет являться неправильным в контексте 
> текущего объяснения.

Переходим в исходный класс `Point2DEx005()` и дополняем поведением: `изменить координату Х`, `изменить координату Y`.

Для этого начинаем писать в `IDEA` `pu` и выбираем подсказку `public void setX(int x) {...}`.

    public void setX(int value) {
        this.x = value;
    }

    public void setY(int value) {
        this.y = value;
    }

Нужно обязательно писать этот `this.`? Нет, не нужно. Но потихоньку надо привыкать потому что в больших системах надо 
понимать в какой момент работаешь с текущими полями, а в какой момент с полями, так сказать базовых классов.

Теперь в клиентском коде, с помощью `a.setX(12)` есть доступ к записи значения координаты точки `a` на `12` и доступ к 
чтению:

      a.setX(12);
      System.out.println(a.getX());

Таким образом разграничили права доступа. Отдельный функционал отвечает за изменение и отдельный за чтение данных. 

> Ещё эти методы называют `сеттеры` и `геттеры`. 

Нужен этот функционал всегда? Нет, не нужно. Но в некоторых случаях надо четко выделять: для этого будем только чтением 
заниматься, а вот для этого будем только записью заниматься. 

Пример. Есть сущность `account`, для аккаунта есть `username` и есть `password`. Естественно, пароль должен видеть 
никто по большому счету, но его можно изменить. А для никнейма: его видят все, но его никто не должен менять, или его 
нельзя изменить. Вот ещё одно поведение.

#### Документация. 0:37:41
Сергей всегда за описание документации, но здесь надо смотреть как работают в команде. Если посыл "нужно делать" - 
делаем, если "не нужно", то всё равно делаем только втихаря. 

Напр., обычный комментарий, особенно начинающие так делают:

      public class Point2D {
         private int x, y;    // Это координата х и у.
      }

Такие комментарии не нужно писать. Теперь нужно описывать что делает метод, класс, что делает этот конкретный кусок 
кода. 

Описание класса. Строкой выше начинаем `/**`, VS Code дополнит концовку `*/` - это границы блока комментария. В `IDEA`
`/**`, далее `Enter` - авто генерация концовки комментария. Можно пропустить до комментария 2 пустые строки.

    /**
    * Это точка 2D
    */
    public class Point2D {
        private int x, y;    // Это координата х и у.
    }

Описание конструктора с 2-мя аргументами. Также `/**` + `Enter` - получится:

    /**
     * Это конструктор ...
     * @param valueX это координата X
     * @param valueY это координата Y
     */

Теперь наводя курсор мыши в клиентском коде на конструктор `Point2D(0, 2)` можно увидеть подсказку из документации, 
написанную ранее в классе `Point2D`. Это окно с подсказкой называется `Intellisensional`. Таким образом создается 
собственная документация. Правильный ли этот результат? Сергей говорит, что в его практике - правильный. Даже если 
отказаться от документации в какой-то момент, сгрузится в какой-то отдельный файл. Потом при необходимости можно будет 
восстановить что там и как?

В некоторых случаях будут говорить что код должен быть самодокументированным. С одной стороны и это правильно, но 
нельзя забывать про документацию. Технические писатели точно скажут спасибо за документацию.

#### Что такое static 0:40:16
До этого выяснили что есть классы и экземпляры классов. Что такое `static`? Теперь в клиентском коде можно определить 
как `Point2D`, дальше написать `.distance()` и аргументами передать наши точки `a` и `b`. 

    public class Point2DEx005 {
       static double distance(Point2DEx005 a, Point2DEx005 b) {
           return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2)); // ошибка в лекции: 1- b(x)-a(x); 2- a(x)-b(x)
    }

    public class PointMethodEx005 {
      
      Point2DEx005.distance(a, b);
    }

> Теперь метод `distance()` перемещен из клиентского кода в класс. Сергей не показал перенос метода, код не 
> компилировался пока метод, был в клиентском коде.

Раньше функционал, который был в каком-то непонятном методе в рамках класса `PointMethod`, теперь этот функционал 
вынесен отдельно в соответствующую сущность `Point2D`, т.е. точки. Все что имеет к нему отношение - пусть там и 
валяется.

    public class PointMethodEx005 {
      var dis = Point2DEx005.distance(a, b);
      System.out.println(dis);
    }

#### Вывод.
Итак, посмотрели что такое классы, экземпляры классов. Если есть `static` +- нужно обращаться через имя типа 
(внимательно!), не через конкретный экземпляр, т.е. `Point2D a =` - где `a` - конкретный экземпляр, `Point2D` - тип. 
Соответственно, для статических членов обращаемся через имя типа.

### Концепты ООП. Инкапсуляция. 0:42:20
Дальше задача разобраться с концептами ООП и начнется с `инкапсуляции`. Первый принцип ООП - инкапсуляция.

_**Инкапсуляция**_ - это свойство системы, позволяющее объединить данные и методы, работающие с ними в классе, скрыв 
детали реализации и защитив от пользователя этого класса объектов.

В самом простом представлении инкапсуляции - объединение данных и логики обработки этих данных плюс сокрытие деталей 
реализации. Что это значит? Когда описывали точку, внутри была куча всякого, напр., как выводить точку на экран? 
Описали метод `getInfo()`, затем сделали переопределение `toString()` и т.д. Всё это есть детали реализации и каким 
образом это реализовано? Зачем там описаны 3 конструктора, которые друг друга вызывают? Это есть не что иное, как 
сокрытие деталей реализации. 

#### Робот.
Теперь попробуем описать систему робота, которого можно включить, есть имя и есть возможность определения уровня. Как 
бы вы стали это делать? Начнем с самого "топорного" кода и будем постепенно улучшать.










     
### Snippets

1. ctor  - IDEA, don't work
2. get; set;
3. docs - IDEA, don't work



## 11

## 22

## 33
